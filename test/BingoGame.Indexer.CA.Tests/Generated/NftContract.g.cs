// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: nft_contract.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace AElf.Contracts.NFT {

  /// <summary>Holder for reflection information generated from nft_contract.proto</summary>
  public static partial class NftContractReflection {

    #region Descriptor
    /// <summary>File descriptor for nft_contract.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static NftContractReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChJuZnRfY29udHJhY3QucHJvdG8SA25mdBoPYWVsZi9jb3JlLnByb3RvGhJh",
            "ZWxmL29wdGlvbnMucHJvdG8aCmFjczEucHJvdG8aFXRyYW5zYWN0aW9uX2Zl",
            "ZS5wcm90bxoUYXV0aG9yaXR5X2luZm8ucHJvdG8aG2dvb2dsZS9wcm90b2J1",
            "Zi9lbXB0eS5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3Rv",
            "ImEKCE5GVFR5cGVzEicKBXZhbHVlGAEgAygLMhgubmZ0Lk5GVFR5cGVzLlZh",
            "bHVlRW50cnkaLAoKVmFsdWVFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUY",
            "AiABKAk6AjgBIo0CCgtDcmVhdGVJbnB1dBIQCghuZnRfdHlwZRgBIAEoCRIV",
            "Cg1wcm90b2NvbF9uYW1lGAIgASgJEhQKDHRvdGFsX3N1cHBseRgDIAEoAxIe",
            "CgdjcmVhdG9yGAQgASgLMg0uYWVsZi5BZGRyZXNzEhMKC2lzX2J1cm5hYmxl",
            "GAUgASgIEhYKDmlzc3VlX2NoYWluX2lkGAYgASgFEh8KCG1ldGFkYXRhGAcg",
            "ASgLMg0ubmZ0Lk1ldGFkYXRhEhAKCGJhc2VfdXJpGAggASgJEhkKEWlzX3Rv",
            "a2VuX2lkX3JldXNlGAkgASgIEiQKC21pbnRlcl9saXN0GAogASgLMg8ubmZ0",
            "Lk1pbnRlckxpc3QiJwoVQ3Jvc3NDaGFpbkNyZWF0ZUlucHV0Eg4KBnN5bWJv",
            "bBgBIAEoCSJqCg1UcmFuc2ZlcklucHV0EhkKAnRvGAEgASgLMg0uYWVsZi5B",
            "ZGRyZXNzEg4KBnN5bWJvbBgCIAEoCRIQCgh0b2tlbl9pZBgDIAEoAxIMCgRt",
            "ZW1vGAQgASgJEg4KBmFtb3VudBgFIAEoAyKLAQoRVHJhbnNmZXJGcm9tSW5w",
            "dXQSGwoEZnJvbRgBIAEoCzINLmFlbGYuQWRkcmVzcxIZCgJ0bxgCIAEoCzIN",
            "LmFlbGYuQWRkcmVzcxIOCgZzeW1ib2wYAyABKAkSEAoIdG9rZW5faWQYBCAB",
            "KAMSDAoEbWVtbxgFIAEoCRIOCgZhbW91bnQYBiABKAMiYAoMQXBwcm92ZUlu",
            "cHV0Eh4KB3NwZW5kZXIYASABKAsyDS5hZWxmLkFkZHJlc3MSDgoGc3ltYm9s",
            "GAIgASgJEhAKCHRva2VuX2lkGAMgASgDEg4KBmFtb3VudBgEIAEoAyJiCg5V",
            "bkFwcHJvdmVJbnB1dBIeCgdzcGVuZGVyGAEgASgLMg0uYWVsZi5BZGRyZXNz",
            "Eg4KBnN5bWJvbBgCIAEoCRIQCgh0b2tlbl9pZBgDIAEoAxIOCgZhbW91bnQY",
            "BCABKAMiWQoUQXBwcm92ZVByb3RvY29sSW5wdXQSHwoIb3BlcmF0b3IYASAB",
            "KAsyDS5hZWxmLkFkZHJlc3MSDgoGc3ltYm9sGAIgASgJEhAKCGFwcHJvdmVk",
            "GAMgASgIIisKC0FkZHJlc3NMaXN0EhwKBXZhbHVlGAEgAygLMg0uYWVsZi5B",
            "ZGRyZXNzIkQKFEdldE9wZXJhdG9yTGlzdElucHV0Eg4KBnN5bWJvbBgBIAEo",
            "CRIcCgVvd25lchgCIAEoCzINLmFlbGYuQWRkcmVzcyI9CglCdXJuSW5wdXQS",
            "DgoGc3ltYm9sGAEgASgJEhAKCHRva2VuX2lkGAIgASgDEg4KBmFtb3VudBgD",
            "IAEoAyLiAQoNQXNzZW1ibGVJbnB1dBIOCgZzeW1ib2wYASABKAkSHAoFb3du",
            "ZXIYAiABKAsyDS5hZWxmLkFkZHJlc3MSCwoDdXJpGAMgASgJEg0KBWFsaWFz",
            "GAQgASgJEh8KCG1ldGFkYXRhGAUgASgLMg0ubmZ0Lk1ldGFkYXRhEioKDmFz",
            "c2VtYmxlZF9uZnRzGAYgASgLMhIubmZ0LkFzc2VtYmxlZE5mdHMSKAoNYXNz",
            "ZW1ibGVkX2Z0cxgHIAEoCzIRLm5mdC5Bc3NlbWJsZWRGdHMSEAoIdG9rZW5f",
            "aWQYCCABKAMiUgoQRGlzYXNzZW1ibGVJbnB1dBIOCgZzeW1ib2wYASABKAkS",
            "EAoIdG9rZW5faWQYAiABKAMSHAoFb3duZXIYAyABKAsyDS5hZWxmLkFkZHJl",
            "c3MiKgoKTWludGVyTGlzdBIcCgV2YWx1ZRgBIAMoCzINLmFlbGYuQWRkcmVz",
            "cyKaAQoJTWludElucHV0Eg4KBnN5bWJvbBgBIAEoCRIcCgVvd25lchgCIAEo",
            "CzINLmFlbGYuQWRkcmVzcxILCgN1cmkYAyABKAkSDQoFYWxpYXMYBCABKAkS",
            "HwoIbWV0YWRhdGEYBSABKAsyDS5uZnQuTWV0YWRhdGESEAoIcXVhbnRpdHkY",
            "BiABKAMSEAoIdG9rZW5faWQYByABKAMiUQoPR2V0QmFsYW5jZUlucHV0EhwK",
            "BW93bmVyGAEgASgLMg0uYWVsZi5BZGRyZXNzEg4KBnN5bWJvbBgCIAEoCRIQ",
            "Cgh0b2tlbl9pZBgDIAEoAyJaChpHZXRCYWxhbmNlQnlUb2tlbkhhc2hJbnB1",
            "dBIcCgVvd25lchgBIAEoCzINLmFlbGYuQWRkcmVzcxIeCgp0b2tlbl9oYXNo",
            "GAIgASgLMgouYWVsZi5IYXNoImEKEEdldEJhbGFuY2VPdXRwdXQSHAoFb3du",
            "ZXIYASABKAsyDS5hZWxmLkFkZHJlc3MSHgoKdG9rZW5faGFzaBgCIAEoCzIK",
            "LmFlbGYuSGFzaBIPCgdiYWxhbmNlGAMgASgDInMKEUdldEFsbG93YW5jZUlu",
            "cHV0Eg4KBnN5bWJvbBgBIAEoCRIQCgh0b2tlbl9pZBgCIAEoAxIcCgVvd25l",
            "chgDIAEoCzINLmFlbGYuQWRkcmVzcxIeCgdzcGVuZGVyGAQgASgLMg0uYWVs",
            "Zi5BZGRyZXNzInwKHEdldEFsbG93YW5jZUJ5VG9rZW5IYXNoSW5wdXQSHgoK",
            "dG9rZW5faGFzaBgBIAEoCzIKLmFlbGYuSGFzaBIcCgVvd25lchgCIAEoCzIN",
            "LmFlbGYuQWRkcmVzcxIeCgdzcGVuZGVyGAMgASgLMg0uYWVsZi5BZGRyZXNz",
            "IoUBChJHZXRBbGxvd2FuY2VPdXRwdXQSHgoKdG9rZW5faGFzaBgBIAEoCzIK",
            "LmFlbGYuSGFzaBIRCglhbGxvd2FuY2UYAiABKAMSHAoFb3duZXIYAyABKAsy",
            "DS5hZWxmLkFkZHJlc3MSHgoHc3BlbmRlchgEIAEoCzINLmFlbGYuQWRkcmVz",
            "cyI7ChdDYWxjdWxhdGVUb2tlbkhhc2hJbnB1dBIOCgZzeW1ib2wYASABKAkS",
            "EAoIdG9rZW5faWQYAiABKAMimwIKD05GVFByb3RvY29sSW5mbxIOCgZzeW1i",
            "b2wYASABKAkSDgoGc3VwcGx5GAIgASgDEhQKDHRvdGFsX3N1cHBseRgDIAEo",
            "AxIeCgdjcmVhdG9yGAQgASgLMg0uYWVsZi5BZGRyZXNzEhAKCGJhc2VfdXJp",
            "GAUgASgJEhMKC2lzX2J1cm5hYmxlGAYgASgIEhYKDmlzc3VlX2NoYWluX2lk",
            "GAcgASgFEh8KCG1ldGFkYXRhGAggASgLMg0ubmZ0Lk1ldGFkYXRhEhAKCG5m",
            "dF90eXBlGAkgASgJEhUKDXByb3RvY29sX25hbWUYCiABKAkSGQoRaXNfdG9r",
            "ZW5faWRfcmV1c2UYCyABKAgSDgoGaXNzdWVkGAwgASgDIogCCgdORlRJbmZv",
            "Eg4KBnN5bWJvbBgBIAEoCRIVCg1wcm90b2NvbF9uYW1lGAIgASgJEhAKCHRv",
            "a2VuX2lkGAMgASgDEh4KB2NyZWF0b3IYBCABKAsyDS5hZWxmLkFkZHJlc3MS",
            "HgoHbWludGVycxgFIAMoCzINLmFlbGYuQWRkcmVzcxIfCghtZXRhZGF0YRgG",
            "IAEoCzINLm5mdC5NZXRhZGF0YRIQCghxdWFudGl0eRgHIAEoAxILCgN1cmkY",
            "CCABKAkSEAoIYmFzZV91cmkYCSABKAkSDQoFYWxpYXMYCiABKAkSEQoJaXNf",
            "YnVybmVkGAsgASgIEhAKCG5mdF90eXBlGAwgASgJImEKCE1ldGFkYXRhEicK",
            "BXZhbHVlGAEgAygLMhgubmZ0Lk1ldGFkYXRhLlZhbHVlRW50cnkaLAoKVmFs",
            "dWVFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIkcKD0Fk",
            "ZE1pbnRlcnNJbnB1dBIkCgttaW50ZXJfbGlzdBgBIAEoCzIPLm5mdC5NaW50",
            "ZXJMaXN0Eg4KBnN5bWJvbBgCIAEoCSJKChJSZW1vdmVNaW50ZXJzSW5wdXQS",
            "JAoLbWludGVyX2xpc3QYASABKAsyDy5uZnQuTWludGVyTGlzdBIOCgZzeW1i",
            "b2wYAiABKAkiMwoPR2V0TkZUSW5mb0lucHV0Eg4KBnN5bWJvbBgBIAEoCRIQ",
            "Cgh0b2tlbl9pZBgCIAEoAyJsCgtSZWNhc3RJbnB1dBIOCgZzeW1ib2wYASAB",
            "KAkSEAoIdG9rZW5faWQYAiABKAMSCwoDdXJpGAMgASgJEg0KBWFsaWFzGAQg",
            "ASgJEh8KCG1ldGFkYXRhGAUgASgLMg0ubmZ0Lk1ldGFkYXRhImsKDUFzc2Vt",
            "YmxlZE5mdHMSLAoFdmFsdWUYASADKAsyHS5uZnQuQXNzZW1ibGVkTmZ0cy5W",
            "YWx1ZUVudHJ5GiwKClZhbHVlRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVl",
            "GAIgASgDOgI4ASJpCgxBc3NlbWJsZWRGdHMSKwoFdmFsdWUYASADKAsyHC5u",
            "ZnQuQXNzZW1ibGVkRnRzLlZhbHVlRW50cnkaLAoKVmFsdWVFbnRyeRILCgNr",
            "ZXkYASABKAkSDQoFdmFsdWUYAiABKAM6AjgBIjgKD0FkZE5GVFR5cGVJbnB1",
            "dBIRCglmdWxsX25hbWUYASABKAkSEgoKc2hvcnRfbmFtZRgCIAEoCSKEAgoS",
            "TkZUUHJvdG9jb2xDcmVhdGVkEg4KBnN5bWJvbBgBIAEoCRIVCg1wcm90b2Nv",
            "bF9uYW1lGAIgASgJEhQKDHRvdGFsX3N1cHBseRgDIAEoAxIeCgdjcmVhdG9y",
            "GAQgASgLMg0uYWVsZi5BZGRyZXNzEhMKC2lzX2J1cm5hYmxlGAUgASgIEhYK",
            "Dmlzc3VlX2NoYWluX2lkGAYgASgFEh8KCG1ldGFkYXRhGAcgASgLMg0ubmZ0",
            "Lk1ldGFkYXRhEhAKCGJhc2VfdXJpGAggASgJEhkKEWlzX3Rva2VuX2lkX3Jl",
            "dXNlGAkgASgIEhAKCG5mdF90eXBlGAogASgJOgSguxgBItICCglORlRNaW50",
            "ZWQSDgoGc3ltYm9sGAEgASgJEhUKDXByb3RvY29sX25hbWUYAiABKAkSEAoI",
            "dG9rZW5faWQYAyABKAMSHgoHY3JlYXRvchgEIAEoCzINLmFlbGYuQWRkcmVz",
            "cxIdCgZtaW50ZXIYBSABKAsyDS5hZWxmLkFkZHJlc3MSHwoIbWV0YWRhdGEY",
            "BiABKAsyDS5uZnQuTWV0YWRhdGESHAoFb3duZXIYByABKAsyDS5hZWxmLkFk",
            "ZHJlc3MSCwoDdXJpGAggASgJEhAKCGJhc2VfdXJpGAkgASgJEg0KBWFsaWFz",
            "GAogASgJEhAKCG5mdF90eXBlGAsgASgJEhAKCHF1YW50aXR5GAwgASgDEhYK",
            "DnRvdGFsX3F1YW50aXR5GA0gASgDEh4KCnRva2VuX2hhc2gYDiABKAsyCi5h",
            "ZWxmLkhhc2g6BKC7GAEipwEKC1RyYW5zZmVycmVkEiIKBGZyb20YASABKAsy",
            "DS5hZWxmLkFkZHJlc3NCBYiP9QEBEiAKAnRvGAIgASgLMg0uYWVsZi5BZGRy",
            "ZXNzQgWIj/UBARIVCgZzeW1ib2wYAyABKAlCBYiP9QEBEhcKCHRva2VuX2lk",
            "GAQgASgDQgWIj/UBARIOCgZhbW91bnQYBSABKAMSDAoEbWVtbxgGIAEoCToE",
            "oLsYASKcAQoIQXBwcm92ZWQSIwoFb3duZXIYASABKAsyDS5hZWxmLkFkZHJl",
            "c3NCBYiP9QEBEiUKB3NwZW5kZXIYAiABKAsyDS5hZWxmLkFkZHJlc3NCBYiP",
            "9QEBEhUKBnN5bWJvbBgDIAEoCUIFiI/1AQESFwoIdG9rZW5faWQYBCABKANC",
            "BYiP9QEBEg4KBmFtb3VudBgFIAEoAzoEoLsYASKpAQoKVW5BcHByb3ZlZBIj",
            "CgVvd25lchgBIAEoCzINLmFlbGYuQWRkcmVzc0IFiI/1AQESJQoHc3BlbmRl",
            "chgCIAEoCzINLmFlbGYuQWRkcmVzc0IFiI/1AQESFQoGc3ltYm9sGAMgASgJ",
            "QgWIj/UBARIXCgh0b2tlbl9pZBgEIAEoA0IFiI/1AQESGQoRY3VycmVudF9h",
            "bGxvd2FuY2UYBSABKAM6BKC7GAEidAoGQnVybmVkEiQKBmJ1cm5lchgBIAEo",
            "CzINLmFlbGYuQWRkcmVzc0IFiI/1AQESFQoGc3ltYm9sGAIgASgJQgWIj/UB",
            "ARIXCgh0b2tlbl9pZBgDIAEoA0IFiI/1AQESDgoGYW1vdW50GAQgASgDOgSg",
            "uxgBIsIBCghSZWNhc3RlZBIVCgZzeW1ib2wYASABKAlCBYiP9QEBEhcKCHRv",
            "a2VuX2lkGAIgASgDQgWIj/UBARIqCgxvbGRfbWV0YWRhdGEYAyABKAsyDS5u",
            "ZnQuTWV0YWRhdGFCBYiP9QEBEioKDG5ld19tZXRhZGF0YRgEIAEoCzINLm5m",
            "dC5NZXRhZGF0YUIFiI/1AQESFAoFYWxpYXMYBSABKAlCBYiP9QEBEhIKA3Vy",
            "aRgGIAEoCUIFiI/1AQE6BKC7GAEipQEKCUFzc2VtYmxlZBIVCgZzeW1ib2wY",
            "ASABKAlCBYiP9QEBEhcKCHRva2VuX2lkGAIgASgDQgWIj/UBARIxCg5hc3Nl",
            "bWJsZWRfbmZ0cxgDIAEoCzISLm5mdC5Bc3NlbWJsZWROZnRzQgWIj/UBARIv",
            "Cg1hc3NlbWJsZWRfZnRzGAQgASgLMhEubmZ0LkFzc2VtYmxlZEZ0c0IFiI/1",
            "AQE6BKC7GAEirgEKDERpc2Fzc2VtYmxlZBIVCgZzeW1ib2wYASABKAlCBYiP",
            "9QEBEhcKCHRva2VuX2lkGAIgASgDQgWIj/UBARI0ChFkaXNhc3NlbWJsZWRf",
            "bmZ0cxgDIAEoCzISLm5mdC5Bc3NlbWJsZWROZnRzQgWIj/UBARIyChBkaXNh",
            "c3NlbWJsZWRfZnRzGAQgASgLMhEubmZ0LkFzc2VtYmxlZEZ0c0IFiI/1AQE6",
            "BKC7GAEiOwoMTkZUVHlwZUFkZGVkEhEKCWZ1bGxfbmFtZRgBIAEoCRISCgpz",
            "aG9ydF9uYW1lGAIgASgJOgSguxgBIioKDk5GVFR5cGVSZW1vdmVkEhIKCnNo",
            "b3J0X25hbWUYASABKAk6BKC7GAEiTQoPTWludGVyTGlzdEFkZGVkEiQKC21p",
            "bnRlcl9saXN0GAEgASgLMg8ubmZ0Lk1pbnRlckxpc3QSDgoGc3ltYm9sGAIg",
            "ASgJOgSguxgBIk8KEU1pbnRlckxpc3RSZW1vdmVkEiQKC21pbnRlcl9saXN0",
            "GAEgASgLMg8ubmZ0Lk1pbnRlckxpc3QSDgoGc3ltYm9sGAIgASgJOgSguxgB",
            "KpYBCgdORlRUeXBlEgcKA0FOWRAAEgcKA0FSVBABEgkKBU1VU0lDEAISEAoM",
            "RE9NQUlOX05BTUVTEAMSEgoOVklSVFVBTF9XT1JMRFMQBBIRCg1UUkFESU5H",
            "X0NBUkRTEAUSEAoMQ09MTEVDVEFCTEVTEAYSCgoGU1BPUlRTEAcSCwoHVVRJ",
            "TElUWRAIEgoKBkJBREdFUxAJMp8OCgtORlRDb250cmFjdBI6CgZDcmVhdGUS",
            "EC5uZnQuQ3JlYXRlSW5wdXQaHC5nb29nbGUucHJvdG9idWYuU3RyaW5nVmFs",
            "dWUiABJIChBDcm9zc0NoYWluQ3JlYXRlEhoubmZ0LkNyb3NzQ2hhaW5DcmVh",
            "dGVJbnB1dBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEiQKBE1pbnQSDi5u",
            "ZnQuTWludElucHV0GgouYWVsZi5IYXNoIgASOAoIVHJhbnNmZXISEi5uZnQu",
            "VHJhbnNmZXJJbnB1dBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEkAKDFRy",
            "YW5zZmVyRnJvbRIWLm5mdC5UcmFuc2ZlckZyb21JbnB1dBoWLmdvb2dsZS5w",
            "cm90b2J1Zi5FbXB0eSIAEjYKB0FwcHJvdmUSES5uZnQuQXBwcm92ZUlucHV0",
            "GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgASOgoJVW5BcHByb3ZlEhMubmZ0",
            "LlVuQXBwcm92ZUlucHV0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgASRgoP",
            "QXBwcm92ZVByb3RvY29sEhkubmZ0LkFwcHJvdmVQcm90b2NvbElucHV0GhYu",
            "Z29vZ2xlLnByb3RvYnVmLkVtcHR5IgASMAoEQnVybhIOLm5mdC5CdXJuSW5w",
            "dXQaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiABIsCghBc3NlbWJsZRISLm5m",
            "dC5Bc3NlbWJsZUlucHV0GgouYWVsZi5IYXNoIgASPgoLRGlzYXNzZW1ibGUS",
            "FS5uZnQuRGlzYXNzZW1ibGVJbnB1dBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0",
            "eSIAEjQKBlJlY2FzdBIQLm5mdC5SZWNhc3RJbnB1dBoWLmdvb2dsZS5wcm90",
            "b2J1Zi5FbXB0eSIAEjwKCkFkZE1pbnRlcnMSFC5uZnQuQWRkTWludGVyc0lu",
            "cHV0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgASQgoNUmVtb3ZlTWludGVy",
            "cxIXLm5mdC5SZW1vdmVNaW50ZXJzSW5wdXQaFi5nb29nbGUucHJvdG9idWYu",
            "RW1wdHkiABI8CgpBZGRORlRUeXBlEhQubmZ0LkFkZE5GVFR5cGVJbnB1dBoW",
            "Lmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEkcKDVJlbW92ZU5GVFR5cGUSHC5n",
            "b29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWUaFi5nb29nbGUucHJvdG9idWYu",
            "RW1wdHkiABJPChJHZXRORlRQcm90b2NvbEluZm8SHC5nb29nbGUucHJvdG9i",
            "dWYuU3RyaW5nVmFsdWUaFC5uZnQuTkZUUHJvdG9jb2xJbmZvIgWIifcBARI3",
            "CgpHZXRORlRJbmZvEhQubmZ0LkdldE5GVEluZm9JbnB1dBoMLm5mdC5ORlRJ",
            "bmZvIgWIifcBARI4ChVHZXRORlRJbmZvQnlUb2tlbkhhc2gSCi5hZWxmLkhh",
            "c2gaDC5uZnQuTkZUSW5mbyIFiIn3AQESQAoKR2V0QmFsYW5jZRIULm5mdC5H",
            "ZXRCYWxhbmNlSW5wdXQaFS5uZnQuR2V0QmFsYW5jZU91dHB1dCIFiIn3AQES",
            "VgoVR2V0QmFsYW5jZUJ5VG9rZW5IYXNoEh8ubmZ0LkdldEJhbGFuY2VCeVRv",
            "a2VuSGFzaElucHV0GhUubmZ0LkdldEJhbGFuY2VPdXRwdXQiBYiJ9wEBEkYK",
            "DEdldEFsbG93YW5jZRIWLm5mdC5HZXRBbGxvd2FuY2VJbnB1dBoXLm5mdC5H",
            "ZXRBbGxvd2FuY2VPdXRwdXQiBYiJ9wEBElwKF0dldEFsbG93YW5jZUJ5VG9r",
            "ZW5IYXNoEiEubmZ0LkdldEFsbG93YW5jZUJ5VG9rZW5IYXNoSW5wdXQaFy5u",
            "ZnQuR2V0QWxsb3dhbmNlT3V0cHV0IgWIifcBARJFCg1HZXRNaW50ZXJMaXN0",
            "EhwuZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlGg8ubmZ0Lk1pbnRlckxp",
            "c3QiBYiJ9wEBEkUKEkNhbGN1bGF0ZVRva2VuSGFzaBIcLm5mdC5DYWxjdWxh",
            "dGVUb2tlbkhhc2hJbnB1dBoKLmFlbGYuSGFzaCIFiIn3AQESOwoLR2V0TkZU",
            "VHlwZXMSFi5nb29nbGUucHJvdG9idWYuRW1wdHkaDS5uZnQuTkZUVHlwZXMi",
            "BYiJ9wEBEkUKD0dldE9wZXJhdG9yTGlzdBIZLm5mdC5HZXRPcGVyYXRvckxp",
            "c3RJbnB1dBoQLm5mdC5BZGRyZXNzTGlzdCIFiIn3AQEaN7LM9gEjQUVsZi5D",
            "b250cmFjdHMuTkZULk5GVENvbnRyYWN0U3RhdGXKyvYBCmFjczEucHJvdG9C",
            "FaoCEkFFbGYuQ29udHJhY3RzLk5GVGIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::AElf.Types.CoreReflection.Descriptor, global::AElf.OptionsReflection.Descriptor, global::AElf.Standards.ACS1.Acs1Reflection.Descriptor, global::AElf.Contracts.MultiToken.TransactionFeeReflection.Descriptor, global::AuthorityInfoReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.EmptyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::AElf.Contracts.NFT.NFTType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.NFTTypes), global::AElf.Contracts.NFT.NFTTypes.Parser, new[]{ "Value" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.CreateInput), global::AElf.Contracts.NFT.CreateInput.Parser, new[]{ "NftType", "ProtocolName", "TotalSupply", "Creator", "IsBurnable", "IssueChainId", "Metadata", "BaseUri", "IsTokenIdReuse", "MinterList" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.CrossChainCreateInput), global::AElf.Contracts.NFT.CrossChainCreateInput.Parser, new[]{ "Symbol" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.TransferInput), global::AElf.Contracts.NFT.TransferInput.Parser, new[]{ "To", "Symbol", "TokenId", "Memo", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.TransferFromInput), global::AElf.Contracts.NFT.TransferFromInput.Parser, new[]{ "From", "To", "Symbol", "TokenId", "Memo", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.ApproveInput), global::AElf.Contracts.NFT.ApproveInput.Parser, new[]{ "Spender", "Symbol", "TokenId", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.UnApproveInput), global::AElf.Contracts.NFT.UnApproveInput.Parser, new[]{ "Spender", "Symbol", "TokenId", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.ApproveProtocolInput), global::AElf.Contracts.NFT.ApproveProtocolInput.Parser, new[]{ "Operator", "Symbol", "Approved" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.AddressList), global::AElf.Contracts.NFT.AddressList.Parser, new[]{ "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetOperatorListInput), global::AElf.Contracts.NFT.GetOperatorListInput.Parser, new[]{ "Symbol", "Owner" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.BurnInput), global::AElf.Contracts.NFT.BurnInput.Parser, new[]{ "Symbol", "TokenId", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.AssembleInput), global::AElf.Contracts.NFT.AssembleInput.Parser, new[]{ "Symbol", "Owner", "Uri", "Alias", "Metadata", "AssembledNfts", "AssembledFts", "TokenId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.DisassembleInput), global::AElf.Contracts.NFT.DisassembleInput.Parser, new[]{ "Symbol", "TokenId", "Owner" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.MinterList), global::AElf.Contracts.NFT.MinterList.Parser, new[]{ "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.MintInput), global::AElf.Contracts.NFT.MintInput.Parser, new[]{ "Symbol", "Owner", "Uri", "Alias", "Metadata", "Quantity", "TokenId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetBalanceInput), global::AElf.Contracts.NFT.GetBalanceInput.Parser, new[]{ "Owner", "Symbol", "TokenId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetBalanceByTokenHashInput), global::AElf.Contracts.NFT.GetBalanceByTokenHashInput.Parser, new[]{ "Owner", "TokenHash" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetBalanceOutput), global::AElf.Contracts.NFT.GetBalanceOutput.Parser, new[]{ "Owner", "TokenHash", "Balance" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetAllowanceInput), global::AElf.Contracts.NFT.GetAllowanceInput.Parser, new[]{ "Symbol", "TokenId", "Owner", "Spender" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetAllowanceByTokenHashInput), global::AElf.Contracts.NFT.GetAllowanceByTokenHashInput.Parser, new[]{ "TokenHash", "Owner", "Spender" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetAllowanceOutput), global::AElf.Contracts.NFT.GetAllowanceOutput.Parser, new[]{ "TokenHash", "Allowance", "Owner", "Spender" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.CalculateTokenHashInput), global::AElf.Contracts.NFT.CalculateTokenHashInput.Parser, new[]{ "Symbol", "TokenId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.NFTProtocolInfo), global::AElf.Contracts.NFT.NFTProtocolInfo.Parser, new[]{ "Symbol", "Supply", "TotalSupply", "Creator", "BaseUri", "IsBurnable", "IssueChainId", "Metadata", "NftType", "ProtocolName", "IsTokenIdReuse", "Issued" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.NFTInfo), global::AElf.Contracts.NFT.NFTInfo.Parser, new[]{ "Symbol", "ProtocolName", "TokenId", "Creator", "Minters", "Metadata", "Quantity", "Uri", "BaseUri", "Alias", "IsBurned", "NftType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.Metadata), global::AElf.Contracts.NFT.Metadata.Parser, new[]{ "Value" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.AddMintersInput), global::AElf.Contracts.NFT.AddMintersInput.Parser, new[]{ "MinterList", "Symbol" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.RemoveMintersInput), global::AElf.Contracts.NFT.RemoveMintersInput.Parser, new[]{ "MinterList", "Symbol" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.GetNFTInfoInput), global::AElf.Contracts.NFT.GetNFTInfoInput.Parser, new[]{ "Symbol", "TokenId" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.RecastInput), global::AElf.Contracts.NFT.RecastInput.Parser, new[]{ "Symbol", "TokenId", "Uri", "Alias", "Metadata" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.AssembledNfts), global::AElf.Contracts.NFT.AssembledNfts.Parser, new[]{ "Value" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.AssembledFts), global::AElf.Contracts.NFT.AssembledFts.Parser, new[]{ "Value" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.AddNFTTypeInput), global::AElf.Contracts.NFT.AddNFTTypeInput.Parser, new[]{ "FullName", "ShortName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.NFTProtocolCreated), global::AElf.Contracts.NFT.NFTProtocolCreated.Parser, new[]{ "Symbol", "ProtocolName", "TotalSupply", "Creator", "IsBurnable", "IssueChainId", "Metadata", "BaseUri", "IsTokenIdReuse", "NftType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.NFTMinted), global::AElf.Contracts.NFT.NFTMinted.Parser, new[]{ "Symbol", "ProtocolName", "TokenId", "Creator", "Minter", "Metadata", "Owner", "Uri", "BaseUri", "Alias", "NftType", "Quantity", "TotalQuantity", "TokenHash" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.Transferred), global::AElf.Contracts.NFT.Transferred.Parser, new[]{ "From", "To", "Symbol", "TokenId", "Amount", "Memo" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.Approved), global::AElf.Contracts.NFT.Approved.Parser, new[]{ "Owner", "Spender", "Symbol", "TokenId", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.UnApproved), global::AElf.Contracts.NFT.UnApproved.Parser, new[]{ "Owner", "Spender", "Symbol", "TokenId", "CurrentAllowance" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.Burned), global::AElf.Contracts.NFT.Burned.Parser, new[]{ "Burner", "Symbol", "TokenId", "Amount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.Recasted), global::AElf.Contracts.NFT.Recasted.Parser, new[]{ "Symbol", "TokenId", "OldMetadata", "NewMetadata", "Alias", "Uri" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.Assembled), global::AElf.Contracts.NFT.Assembled.Parser, new[]{ "Symbol", "TokenId", "AssembledNfts", "AssembledFts" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.Disassembled), global::AElf.Contracts.NFT.Disassembled.Parser, new[]{ "Symbol", "TokenId", "DisassembledNfts", "DisassembledFts" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.NFTTypeAdded), global::AElf.Contracts.NFT.NFTTypeAdded.Parser, new[]{ "FullName", "ShortName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.NFTTypeRemoved), global::AElf.Contracts.NFT.NFTTypeRemoved.Parser, new[]{ "ShortName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.MinterListAdded), global::AElf.Contracts.NFT.MinterListAdded.Parser, new[]{ "MinterList", "Symbol" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::AElf.Contracts.NFT.MinterListRemoved), global::AElf.Contracts.NFT.MinterListRemoved.Parser, new[]{ "MinterList", "Symbol" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum NFTType {
    [pbr::OriginalName("ANY")] Any = 0,
    [pbr::OriginalName("ART")] Art = 1,
    [pbr::OriginalName("MUSIC")] Music = 2,
    [pbr::OriginalName("DOMAIN_NAMES")] DomainNames = 3,
    [pbr::OriginalName("VIRTUAL_WORLDS")] VirtualWorlds = 4,
    [pbr::OriginalName("TRADING_CARDS")] TradingCards = 5,
    [pbr::OriginalName("COLLECTABLES")] Collectables = 6,
    [pbr::OriginalName("SPORTS")] Sports = 7,
    [pbr::OriginalName("UTILITY")] Utility = 8,
    [pbr::OriginalName("BADGES")] Badges = 9,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Structs
  /// </summary>
  public sealed partial class NFTTypes : pb::IMessage<NFTTypes>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFTTypes> _parser = new pb::MessageParser<NFTTypes>(() => new NFTTypes());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NFTTypes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypes(NFTTypes other) : this() {
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypes Clone() {
      return new NFTTypes(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private static readonly pbc::MapField<string, string>.Codec _map_value_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 10);
    private readonly pbc::MapField<string, string> value_ = new pbc::MapField<string, string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NFTTypes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NFTTypes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Value.Equals(other.Value)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      value_.WriteTo(output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      value_.WriteTo(ref output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += value_.CalculateSize(_map_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NFTTypes other) {
      if (other == null) {
        return;
      }
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            value_.AddEntriesFrom(input, _map_value_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            value_.AddEntriesFrom(ref input, _map_value_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Inputs
  /// </summary>
  public sealed partial class CreateInput : pb::IMessage<CreateInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CreateInput> _parser = new pb::MessageParser<CreateInput>(() => new CreateInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreateInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateInput(CreateInput other) : this() {
      nftType_ = other.nftType_;
      protocolName_ = other.protocolName_;
      totalSupply_ = other.totalSupply_;
      creator_ = other.creator_ != null ? other.creator_.Clone() : null;
      isBurnable_ = other.isBurnable_;
      issueChainId_ = other.issueChainId_;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      baseUri_ = other.baseUri_;
      isTokenIdReuse_ = other.isTokenIdReuse_;
      minterList_ = other.minterList_ != null ? other.minterList_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateInput Clone() {
      return new CreateInput(this);
    }

    /// <summary>Field number for the "nft_type" field.</summary>
    public const int NftTypeFieldNumber = 1;
    private string nftType_ = "";
    /// <summary>
    /// The type of this nft protocol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NftType {
      get { return nftType_; }
      set {
        nftType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "protocol_name" field.</summary>
    public const int ProtocolNameFieldNumber = 2;
    private string protocolName_ = "";
    /// <summary>
    /// The name of this nft protocol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProtocolName {
      get { return protocolName_; }
      set {
        protocolName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "total_supply" field.</summary>
    public const int TotalSupplyFieldNumber = 3;
    private long totalSupply_;
    /// <summary>
    /// The total supply of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TotalSupply {
      get { return totalSupply_; }
      set {
        totalSupply_ = value;
      }
    }

    /// <summary>Field number for the "creator" field.</summary>
    public const int CreatorFieldNumber = 4;
    private global::AElf.Types.Address creator_;
    /// <summary>
    /// The address that created the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Creator {
      get { return creator_; }
      set {
        creator_ = value;
      }
    }

    /// <summary>Field number for the "is_burnable" field.</summary>
    public const int IsBurnableFieldNumber = 5;
    private bool isBurnable_;
    /// <summary>
    /// A flag indicating if this token is burnable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBurnable {
      get { return isBurnable_; }
      set {
        isBurnable_ = value;
      }
    }

    /// <summary>Field number for the "issue_chain_id" field.</summary>
    public const int IssueChainIdFieldNumber = 6;
    private int issueChainId_;
    /// <summary>
    /// The chain id of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int IssueChainId {
      get { return issueChainId_; }
      set {
        issueChainId_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    /// <summary>
    /// The metadata of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "base_uri" field.</summary>
    public const int BaseUriFieldNumber = 8;
    private string baseUri_ = "";
    /// <summary>
    /// Base Uri.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BaseUri {
      get { return baseUri_; }
      set {
        baseUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_token_id_reuse" field.</summary>
    public const int IsTokenIdReuseFieldNumber = 9;
    private bool isTokenIdReuse_;
    /// <summary>
    /// Is token id can be reused.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTokenIdReuse {
      get { return isTokenIdReuse_; }
      set {
        isTokenIdReuse_ = value;
      }
    }

    /// <summary>Field number for the "minter_list" field.</summary>
    public const int MinterListFieldNumber = 10;
    private global::AElf.Contracts.NFT.MinterList minterList_;
    /// <summary>
    /// Initial minter list (creator will be added automatically)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.MinterList MinterList {
      get { return minterList_; }
      set {
        minterList_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreateInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreateInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NftType != other.NftType) return false;
      if (ProtocolName != other.ProtocolName) return false;
      if (TotalSupply != other.TotalSupply) return false;
      if (!object.Equals(Creator, other.Creator)) return false;
      if (IsBurnable != other.IsBurnable) return false;
      if (IssueChainId != other.IssueChainId) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (BaseUri != other.BaseUri) return false;
      if (IsTokenIdReuse != other.IsTokenIdReuse) return false;
      if (!object.Equals(MinterList, other.MinterList)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NftType.Length != 0) hash ^= NftType.GetHashCode();
      if (ProtocolName.Length != 0) hash ^= ProtocolName.GetHashCode();
      if (TotalSupply != 0L) hash ^= TotalSupply.GetHashCode();
      if (creator_ != null) hash ^= Creator.GetHashCode();
      if (IsBurnable != false) hash ^= IsBurnable.GetHashCode();
      if (IssueChainId != 0) hash ^= IssueChainId.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (BaseUri.Length != 0) hash ^= BaseUri.GetHashCode();
      if (IsTokenIdReuse != false) hash ^= IsTokenIdReuse.GetHashCode();
      if (minterList_ != null) hash ^= MinterList.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (NftType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(NftType);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TotalSupply != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSupply);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (IsBurnable != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsBurnable);
      }
      if (IssueChainId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(IssueChainId);
      }
      if (metadata_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(BaseUri);
      }
      if (IsTokenIdReuse != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsTokenIdReuse);
      }
      if (minterList_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(MinterList);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (NftType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(NftType);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TotalSupply != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSupply);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (IsBurnable != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsBurnable);
      }
      if (IssueChainId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(IssueChainId);
      }
      if (metadata_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(BaseUri);
      }
      if (IsTokenIdReuse != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsTokenIdReuse);
      }
      if (minterList_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(MinterList);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NftType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NftType);
      }
      if (ProtocolName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProtocolName);
      }
      if (TotalSupply != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalSupply);
      }
      if (creator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Creator);
      }
      if (IsBurnable != false) {
        size += 1 + 1;
      }
      if (IssueChainId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(IssueChainId);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (BaseUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BaseUri);
      }
      if (IsTokenIdReuse != false) {
        size += 1 + 1;
      }
      if (minterList_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinterList);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreateInput other) {
      if (other == null) {
        return;
      }
      if (other.NftType.Length != 0) {
        NftType = other.NftType;
      }
      if (other.ProtocolName.Length != 0) {
        ProtocolName = other.ProtocolName;
      }
      if (other.TotalSupply != 0L) {
        TotalSupply = other.TotalSupply;
      }
      if (other.creator_ != null) {
        if (creator_ == null) {
          Creator = new global::AElf.Types.Address();
        }
        Creator.MergeFrom(other.Creator);
      }
      if (other.IsBurnable != false) {
        IsBurnable = other.IsBurnable;
      }
      if (other.IssueChainId != 0) {
        IssueChainId = other.IssueChainId;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.BaseUri.Length != 0) {
        BaseUri = other.BaseUri;
      }
      if (other.IsTokenIdReuse != false) {
        IsTokenIdReuse = other.IsTokenIdReuse;
      }
      if (other.minterList_ != null) {
        if (minterList_ == null) {
          MinterList = new global::AElf.Contracts.NFT.MinterList();
        }
        MinterList.MergeFrom(other.MinterList);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            NftType = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TotalSupply = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 40: {
            IsBurnable = input.ReadBool();
            break;
          }
          case 48: {
            IssueChainId = input.ReadInt32();
            break;
          }
          case 58: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 66: {
            BaseUri = input.ReadString();
            break;
          }
          case 72: {
            IsTokenIdReuse = input.ReadBool();
            break;
          }
          case 82: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            NftType = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TotalSupply = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 40: {
            IsBurnable = input.ReadBool();
            break;
          }
          case 48: {
            IssueChainId = input.ReadInt32();
            break;
          }
          case 58: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 66: {
            BaseUri = input.ReadString();
            break;
          }
          case 72: {
            IsTokenIdReuse = input.ReadBool();
            break;
          }
          case 82: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class CrossChainCreateInput : pb::IMessage<CrossChainCreateInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CrossChainCreateInput> _parser = new pb::MessageParser<CrossChainCreateInput>(() => new CrossChainCreateInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CrossChainCreateInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrossChainCreateInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrossChainCreateInput(CrossChainCreateInput other) : this() {
      symbol_ = other.symbol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CrossChainCreateInput Clone() {
      return new CrossChainCreateInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CrossChainCreateInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CrossChainCreateInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CrossChainCreateInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TransferInput : pb::IMessage<TransferInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransferInput> _parser = new pb::MessageParser<TransferInput>(() => new TransferInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransferInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferInput(TransferInput other) : this() {
      to_ = other.to_ != null ? other.to_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      memo_ = other.memo_;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferInput Clone() {
      return new TransferInput(this);
    }

    /// <summary>Field number for the "to" field.</summary>
    public const int ToFieldNumber = 1;
    private global::AElf.Types.Address to_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address To {
      get { return to_; }
      set {
        to_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 3;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 4;
    private string memo_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 5;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransferInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransferInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(To, other.To)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Memo != other.Memo) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (to_ != null) hash ^= To.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (to_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(To);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Memo);
      }
      if (Amount != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (to_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(To);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Memo);
      }
      if (Amount != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (to_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(To);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransferInput other) {
      if (other == null) {
        return;
      }
      if (other.to_ != null) {
        if (to_ == null) {
          To = new global::AElf.Types.Address();
        }
        To.MergeFrom(other.To);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (to_ == null) {
              To = new global::AElf.Types.Address();
            }
            input.ReadMessage(To);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 34: {
            Memo = input.ReadString();
            break;
          }
          case 40: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (to_ == null) {
              To = new global::AElf.Types.Address();
            }
            input.ReadMessage(To);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 34: {
            Memo = input.ReadString();
            break;
          }
          case 40: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class TransferFromInput : pb::IMessage<TransferFromInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TransferFromInput> _parser = new pb::MessageParser<TransferFromInput>(() => new TransferFromInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TransferFromInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferFromInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferFromInput(TransferFromInput other) : this() {
      from_ = other.from_ != null ? other.from_.Clone() : null;
      to_ = other.to_ != null ? other.to_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      memo_ = other.memo_;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TransferFromInput Clone() {
      return new TransferFromInput(this);
    }

    /// <summary>Field number for the "from" field.</summary>
    public const int FromFieldNumber = 1;
    private global::AElf.Types.Address from_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address From {
      get { return from_; }
      set {
        from_ = value;
      }
    }

    /// <summary>Field number for the "to" field.</summary>
    public const int ToFieldNumber = 2;
    private global::AElf.Types.Address to_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address To {
      get { return to_; }
      set {
        to_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 3;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 4;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 5;
    private string memo_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 6;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TransferFromInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TransferFromInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(From, other.From)) return false;
      if (!object.Equals(To, other.To)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Memo != other.Memo) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (from_ != null) hash ^= From.GetHashCode();
      if (to_ != null) hash ^= To.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (from_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(From);
      }
      if (to_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(To);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Memo);
      }
      if (Amount != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (from_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(From);
      }
      if (to_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(To);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Memo);
      }
      if (Amount != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (from_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(From);
      }
      if (to_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(To);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TransferFromInput other) {
      if (other == null) {
        return;
      }
      if (other.from_ != null) {
        if (from_ == null) {
          From = new global::AElf.Types.Address();
        }
        From.MergeFrom(other.From);
      }
      if (other.to_ != null) {
        if (to_ == null) {
          To = new global::AElf.Types.Address();
        }
        To.MergeFrom(other.To);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (from_ == null) {
              From = new global::AElf.Types.Address();
            }
            input.ReadMessage(From);
            break;
          }
          case 18: {
            if (to_ == null) {
              To = new global::AElf.Types.Address();
            }
            input.ReadMessage(To);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 42: {
            Memo = input.ReadString();
            break;
          }
          case 48: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (from_ == null) {
              From = new global::AElf.Types.Address();
            }
            input.ReadMessage(From);
            break;
          }
          case 18: {
            if (to_ == null) {
              To = new global::AElf.Types.Address();
            }
            input.ReadMessage(To);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 42: {
            Memo = input.ReadString();
            break;
          }
          case 48: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ApproveInput : pb::IMessage<ApproveInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ApproveInput> _parser = new pb::MessageParser<ApproveInput>(() => new ApproveInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApproveInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApproveInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApproveInput(ApproveInput other) : this() {
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApproveInput Clone() {
      return new ApproveInput(this);
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 1;
    private global::AElf.Types.Address spender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 3;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 4;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApproveInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApproveInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Spender, other.Spender)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (spender_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (spender_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApproveInput other) {
      if (other == null) {
        return;
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::AElf.Types.Address();
        }
        Spender.MergeFrom(other.Spender);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class UnApproveInput : pb::IMessage<UnApproveInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UnApproveInput> _parser = new pb::MessageParser<UnApproveInput>(() => new UnApproveInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UnApproveInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UnApproveInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UnApproveInput(UnApproveInput other) : this() {
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UnApproveInput Clone() {
      return new UnApproveInput(this);
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 1;
    private global::AElf.Types.Address spender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 3;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 4;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UnApproveInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UnApproveInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Spender, other.Spender)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (spender_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (spender_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UnApproveInput other) {
      if (other == null) {
        return;
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::AElf.Types.Address();
        }
        Spender.MergeFrom(other.Spender);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class ApproveProtocolInput : pb::IMessage<ApproveProtocolInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ApproveProtocolInput> _parser = new pb::MessageParser<ApproveProtocolInput>(() => new ApproveProtocolInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ApproveProtocolInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApproveProtocolInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApproveProtocolInput(ApproveProtocolInput other) : this() {
      operator_ = other.operator_ != null ? other.operator_.Clone() : null;
      symbol_ = other.symbol_;
      approved_ = other.approved_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ApproveProtocolInput Clone() {
      return new ApproveProtocolInput(this);
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 1;
    private global::AElf.Types.Address operator_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Operator {
      get { return operator_; }
      set {
        operator_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "approved" field.</summary>
    public const int ApprovedFieldNumber = 3;
    private bool approved_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Approved {
      get { return approved_; }
      set {
        approved_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ApproveProtocolInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ApproveProtocolInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Operator, other.Operator)) return false;
      if (Symbol != other.Symbol) return false;
      if (Approved != other.Approved) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (operator_ != null) hash ^= Operator.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Approved != false) hash ^= Approved.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (operator_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Operator);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Approved != false) {
        output.WriteRawTag(24);
        output.WriteBool(Approved);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (operator_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Operator);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (Approved != false) {
        output.WriteRawTag(24);
        output.WriteBool(Approved);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (operator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Operator);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Approved != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ApproveProtocolInput other) {
      if (other == null) {
        return;
      }
      if (other.operator_ != null) {
        if (operator_ == null) {
          Operator = new global::AElf.Types.Address();
        }
        Operator.MergeFrom(other.Operator);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Approved != false) {
        Approved = other.Approved;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (operator_ == null) {
              Operator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Operator);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            Approved = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (operator_ == null) {
              Operator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Operator);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            Approved = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AddressList : pb::IMessage<AddressList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AddressList> _parser = new pb::MessageParser<AddressList>(() => new AddressList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AddressList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddressList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddressList(AddressList other) : this() {
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddressList Clone() {
      return new AddressList(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private static readonly pb::FieldCodec<global::AElf.Types.Address> _repeated_value_codec
        = pb::FieldCodec.ForMessage(10, global::AElf.Types.Address.Parser);
    private readonly pbc::RepeatedField<global::AElf.Types.Address> value_ = new pbc::RepeatedField<global::AElf.Types.Address>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::AElf.Types.Address> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AddressList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AddressList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!value_.Equals(other.value_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= value_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      value_.WriteTo(output, _repeated_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      value_.WriteTo(ref output, _repeated_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += value_.CalculateSize(_repeated_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AddressList other) {
      if (other == null) {
        return;
      }
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            value_.AddEntriesFrom(input, _repeated_value_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            value_.AddEntriesFrom(ref input, _repeated_value_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetOperatorListInput : pb::IMessage<GetOperatorListInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetOperatorListInput> _parser = new pb::MessageParser<GetOperatorListInput>(() => new GetOperatorListInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetOperatorListInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetOperatorListInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetOperatorListInput(GetOperatorListInput other) : this() {
      symbol_ = other.symbol_;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetOperatorListInput Clone() {
      return new GetOperatorListInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 2;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetOperatorListInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetOperatorListInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetOperatorListInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class BurnInput : pb::IMessage<BurnInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BurnInput> _parser = new pb::MessageParser<BurnInput>(() => new BurnInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BurnInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BurnInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BurnInput(BurnInput other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BurnInput Clone() {
      return new BurnInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 3;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BurnInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BurnInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BurnInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 24: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 24: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AssembleInput : pb::IMessage<AssembleInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AssembleInput> _parser = new pb::MessageParser<AssembleInput>(() => new AssembleInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AssembleInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembleInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembleInput(AssembleInput other) : this() {
      symbol_ = other.symbol_;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      uri_ = other.uri_;
      alias_ = other.alias_;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      assembledNfts_ = other.assembledNfts_ != null ? other.assembledNfts_.Clone() : null;
      assembledFts_ = other.assembledFts_ != null ? other.assembledFts_.Clone() : null;
      tokenId_ = other.tokenId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembleInput Clone() {
      return new AssembleInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 2;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 3;
    private string uri_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 4;
    private string alias_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 5;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "assembled_nfts" field.</summary>
    public const int AssembledNftsFieldNumber = 6;
    private global::AElf.Contracts.NFT.AssembledNfts assembledNfts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.AssembledNfts AssembledNfts {
      get { return assembledNfts_; }
      set {
        assembledNfts_ = value;
      }
    }

    /// <summary>Field number for the "assembled_fts" field.</summary>
    public const int AssembledFtsFieldNumber = 7;
    private global::AElf.Contracts.NFT.AssembledFts assembledFts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.AssembledFts AssembledFts {
      get { return assembledFts_; }
      set {
        assembledFts_ = value;
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 8;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AssembleInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AssembleInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (Uri != other.Uri) return false;
      if (Alias != other.Alias) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(AssembledNfts, other.AssembledNfts)) return false;
      if (!object.Equals(AssembledFts, other.AssembledFts)) return false;
      if (TokenId != other.TokenId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (assembledNfts_ != null) hash ^= AssembledNfts.GetHashCode();
      if (assembledFts_ != null) hash ^= AssembledFts.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Alias);
      }
      if (metadata_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Metadata);
      }
      if (assembledNfts_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AssembledNfts);
      }
      if (assembledFts_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AssembledFts);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Alias);
      }
      if (metadata_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Metadata);
      }
      if (assembledNfts_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(AssembledNfts);
      }
      if (assembledFts_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(AssembledFts);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (Alias.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Alias);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (assembledNfts_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AssembledNfts);
      }
      if (assembledFts_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AssembledFts);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AssembleInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.assembledNfts_ != null) {
        if (assembledNfts_ == null) {
          AssembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
        }
        AssembledNfts.MergeFrom(other.AssembledNfts);
      }
      if (other.assembledFts_ != null) {
        if (assembledFts_ == null) {
          AssembledFts = new global::AElf.Contracts.NFT.AssembledFts();
        }
        AssembledFts.MergeFrom(other.AssembledFts);
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            Uri = input.ReadString();
            break;
          }
          case 34: {
            Alias = input.ReadString();
            break;
          }
          case 42: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 50: {
            if (assembledNfts_ == null) {
              AssembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
            }
            input.ReadMessage(AssembledNfts);
            break;
          }
          case 58: {
            if (assembledFts_ == null) {
              AssembledFts = new global::AElf.Contracts.NFT.AssembledFts();
            }
            input.ReadMessage(AssembledFts);
            break;
          }
          case 64: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            Uri = input.ReadString();
            break;
          }
          case 34: {
            Alias = input.ReadString();
            break;
          }
          case 42: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 50: {
            if (assembledNfts_ == null) {
              AssembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
            }
            input.ReadMessage(AssembledNfts);
            break;
          }
          case 58: {
            if (assembledFts_ == null) {
              AssembledFts = new global::AElf.Contracts.NFT.AssembledFts();
            }
            input.ReadMessage(AssembledFts);
            break;
          }
          case 64: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class DisassembleInput : pb::IMessage<DisassembleInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DisassembleInput> _parser = new pb::MessageParser<DisassembleInput>(() => new DisassembleInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DisassembleInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DisassembleInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DisassembleInput(DisassembleInput other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DisassembleInput Clone() {
      return new DisassembleInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 3;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DisassembleInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DisassembleInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Owner);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Owner);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DisassembleInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class MinterList : pb::IMessage<MinterList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MinterList> _parser = new pb::MessageParser<MinterList>(() => new MinterList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MinterList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterList(MinterList other) : this() {
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterList Clone() {
      return new MinterList(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private static readonly pb::FieldCodec<global::AElf.Types.Address> _repeated_value_codec
        = pb::FieldCodec.ForMessage(10, global::AElf.Types.Address.Parser);
    private readonly pbc::RepeatedField<global::AElf.Types.Address> value_ = new pbc::RepeatedField<global::AElf.Types.Address>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::AElf.Types.Address> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MinterList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MinterList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!value_.Equals(other.value_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= value_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      value_.WriteTo(output, _repeated_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      value_.WriteTo(ref output, _repeated_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += value_.CalculateSize(_repeated_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MinterList other) {
      if (other == null) {
        return;
      }
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            value_.AddEntriesFrom(input, _repeated_value_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            value_.AddEntriesFrom(ref input, _repeated_value_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class MintInput : pb::IMessage<MintInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MintInput> _parser = new pb::MessageParser<MintInput>(() => new MintInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MintInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MintInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MintInput(MintInput other) : this() {
      symbol_ = other.symbol_;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      uri_ = other.uri_;
      alias_ = other.alias_;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      quantity_ = other.quantity_;
      tokenId_ = other.tokenId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MintInput Clone() {
      return new MintInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 2;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 3;
    private string uri_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 4;
    private string alias_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 5;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "quantity" field.</summary>
    public const int QuantityFieldNumber = 6;
    private long quantity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Quantity {
      get { return quantity_; }
      set {
        quantity_ = value;
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 7;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MintInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MintInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (Uri != other.Uri) return false;
      if (Alias != other.Alias) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (Quantity != other.Quantity) return false;
      if (TokenId != other.TokenId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (Quantity != 0L) hash ^= Quantity.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Alias);
      }
      if (metadata_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Metadata);
      }
      if (Quantity != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(Quantity);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Alias);
      }
      if (metadata_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Metadata);
      }
      if (Quantity != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(Quantity);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (Alias.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Alias);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (Quantity != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Quantity);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MintInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.Quantity != 0L) {
        Quantity = other.Quantity;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            Uri = input.ReadString();
            break;
          }
          case 34: {
            Alias = input.ReadString();
            break;
          }
          case 42: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 48: {
            Quantity = input.ReadInt64();
            break;
          }
          case 56: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            Uri = input.ReadString();
            break;
          }
          case 34: {
            Alias = input.ReadString();
            break;
          }
          case 42: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 48: {
            Quantity = input.ReadInt64();
            break;
          }
          case 56: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetBalanceInput : pb::IMessage<GetBalanceInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetBalanceInput> _parser = new pb::MessageParser<GetBalanceInput>(() => new GetBalanceInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetBalanceInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceInput(GetBalanceInput other) : this() {
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceInput Clone() {
      return new GetBalanceInput(this);
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 1;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 3;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetBalanceInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetBalanceInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Owner, other.Owner)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetBalanceInput other) {
      if (other == null) {
        return;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetBalanceByTokenHashInput : pb::IMessage<GetBalanceByTokenHashInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetBalanceByTokenHashInput> _parser = new pb::MessageParser<GetBalanceByTokenHashInput>(() => new GetBalanceByTokenHashInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetBalanceByTokenHashInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceByTokenHashInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceByTokenHashInput(GetBalanceByTokenHashInput other) : this() {
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      tokenHash_ = other.tokenHash_ != null ? other.tokenHash_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceByTokenHashInput Clone() {
      return new GetBalanceByTokenHashInput(this);
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 1;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "token_hash" field.</summary>
    public const int TokenHashFieldNumber = 2;
    private global::AElf.Types.Hash tokenHash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Hash TokenHash {
      get { return tokenHash_; }
      set {
        tokenHash_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetBalanceByTokenHashInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetBalanceByTokenHashInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(TokenHash, other.TokenHash)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (tokenHash_ != null) hash ^= TokenHash.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (tokenHash_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TokenHash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (tokenHash_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TokenHash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (tokenHash_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenHash);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetBalanceByTokenHashInput other) {
      if (other == null) {
        return;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.tokenHash_ != null) {
        if (tokenHash_ == null) {
          TokenHash = new global::AElf.Types.Hash();
        }
        TokenHash.MergeFrom(other.TokenHash);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetBalanceOutput : pb::IMessage<GetBalanceOutput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetBalanceOutput> _parser = new pb::MessageParser<GetBalanceOutput>(() => new GetBalanceOutput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetBalanceOutput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceOutput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceOutput(GetBalanceOutput other) : this() {
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      tokenHash_ = other.tokenHash_ != null ? other.tokenHash_.Clone() : null;
      balance_ = other.balance_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetBalanceOutput Clone() {
      return new GetBalanceOutput(this);
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 1;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "token_hash" field.</summary>
    public const int TokenHashFieldNumber = 2;
    private global::AElf.Types.Hash tokenHash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Hash TokenHash {
      get { return tokenHash_; }
      set {
        tokenHash_ = value;
      }
    }

    /// <summary>Field number for the "balance" field.</summary>
    public const int BalanceFieldNumber = 3;
    private long balance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Balance {
      get { return balance_; }
      set {
        balance_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetBalanceOutput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetBalanceOutput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(TokenHash, other.TokenHash)) return false;
      if (Balance != other.Balance) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (tokenHash_ != null) hash ^= TokenHash.GetHashCode();
      if (Balance != 0L) hash ^= Balance.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (tokenHash_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TokenHash);
      }
      if (Balance != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Balance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (tokenHash_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TokenHash);
      }
      if (Balance != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Balance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (tokenHash_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenHash);
      }
      if (Balance != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Balance);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetBalanceOutput other) {
      if (other == null) {
        return;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.tokenHash_ != null) {
        if (tokenHash_ == null) {
          TokenHash = new global::AElf.Types.Hash();
        }
        TokenHash.MergeFrom(other.TokenHash);
      }
      if (other.Balance != 0L) {
        Balance = other.Balance;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
          case 24: {
            Balance = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
          case 24: {
            Balance = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetAllowanceInput : pb::IMessage<GetAllowanceInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetAllowanceInput> _parser = new pb::MessageParser<GetAllowanceInput>(() => new GetAllowanceInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetAllowanceInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceInput(GetAllowanceInput other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceInput Clone() {
      return new GetAllowanceInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 3;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 4;
    private global::AElf.Types.Address spender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetAllowanceInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetAllowanceInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Spender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (owner_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Spender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetAllowanceInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::AElf.Types.Address();
        }
        Spender.MergeFrom(other.Spender);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 34: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 34: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetAllowanceByTokenHashInput : pb::IMessage<GetAllowanceByTokenHashInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetAllowanceByTokenHashInput> _parser = new pb::MessageParser<GetAllowanceByTokenHashInput>(() => new GetAllowanceByTokenHashInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetAllowanceByTokenHashInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceByTokenHashInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceByTokenHashInput(GetAllowanceByTokenHashInput other) : this() {
      tokenHash_ = other.tokenHash_ != null ? other.tokenHash_.Clone() : null;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceByTokenHashInput Clone() {
      return new GetAllowanceByTokenHashInput(this);
    }

    /// <summary>Field number for the "token_hash" field.</summary>
    public const int TokenHashFieldNumber = 1;
    private global::AElf.Types.Hash tokenHash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Hash TokenHash {
      get { return tokenHash_; }
      set {
        tokenHash_ = value;
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 2;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 3;
    private global::AElf.Types.Address spender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetAllowanceByTokenHashInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetAllowanceByTokenHashInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenHash, other.TokenHash)) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenHash_ != null) hash ^= TokenHash.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenHash_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenHash);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Spender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenHash_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenHash);
      }
      if (owner_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Spender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (tokenHash_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenHash);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetAllowanceByTokenHashInput other) {
      if (other == null) {
        return;
      }
      if (other.tokenHash_ != null) {
        if (tokenHash_ == null) {
          TokenHash = new global::AElf.Types.Hash();
        }
        TokenHash.MergeFrom(other.TokenHash);
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::AElf.Types.Address();
        }
        Spender.MergeFrom(other.Spender);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
          case 18: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 26: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetAllowanceOutput : pb::IMessage<GetAllowanceOutput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetAllowanceOutput> _parser = new pb::MessageParser<GetAllowanceOutput>(() => new GetAllowanceOutput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetAllowanceOutput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceOutput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceOutput(GetAllowanceOutput other) : this() {
      tokenHash_ = other.tokenHash_ != null ? other.tokenHash_.Clone() : null;
      allowance_ = other.allowance_;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetAllowanceOutput Clone() {
      return new GetAllowanceOutput(this);
    }

    /// <summary>Field number for the "token_hash" field.</summary>
    public const int TokenHashFieldNumber = 1;
    private global::AElf.Types.Hash tokenHash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Hash TokenHash {
      get { return tokenHash_; }
      set {
        tokenHash_ = value;
      }
    }

    /// <summary>Field number for the "allowance" field.</summary>
    public const int AllowanceFieldNumber = 2;
    private long allowance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Allowance {
      get { return allowance_; }
      set {
        allowance_ = value;
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 3;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 4;
    private global::AElf.Types.Address spender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetAllowanceOutput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetAllowanceOutput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TokenHash, other.TokenHash)) return false;
      if (Allowance != other.Allowance) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (tokenHash_ != null) hash ^= TokenHash.GetHashCode();
      if (Allowance != 0L) hash ^= Allowance.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tokenHash_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenHash);
      }
      if (Allowance != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Allowance);
      }
      if (owner_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Spender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tokenHash_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TokenHash);
      }
      if (Allowance != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Allowance);
      }
      if (owner_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Spender);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (tokenHash_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenHash);
      }
      if (Allowance != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Allowance);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetAllowanceOutput other) {
      if (other == null) {
        return;
      }
      if (other.tokenHash_ != null) {
        if (tokenHash_ == null) {
          TokenHash = new global::AElf.Types.Hash();
        }
        TokenHash.MergeFrom(other.TokenHash);
      }
      if (other.Allowance != 0L) {
        Allowance = other.Allowance;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::AElf.Types.Address();
        }
        Spender.MergeFrom(other.Spender);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
          case 16: {
            Allowance = input.ReadInt64();
            break;
          }
          case 26: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 34: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
          case 16: {
            Allowance = input.ReadInt64();
            break;
          }
          case 26: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 34: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class CalculateTokenHashInput : pb::IMessage<CalculateTokenHashInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CalculateTokenHashInput> _parser = new pb::MessageParser<CalculateTokenHashInput>(() => new CalculateTokenHashInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CalculateTokenHashInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CalculateTokenHashInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CalculateTokenHashInput(CalculateTokenHashInput other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CalculateTokenHashInput Clone() {
      return new CalculateTokenHashInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CalculateTokenHashInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CalculateTokenHashInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CalculateTokenHashInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NFTProtocolInfo : pb::IMessage<NFTProtocolInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFTProtocolInfo> _parser = new pb::MessageParser<NFTProtocolInfo>(() => new NFTProtocolInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NFTProtocolInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTProtocolInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTProtocolInfo(NFTProtocolInfo other) : this() {
      symbol_ = other.symbol_;
      supply_ = other.supply_;
      totalSupply_ = other.totalSupply_;
      creator_ = other.creator_ != null ? other.creator_.Clone() : null;
      baseUri_ = other.baseUri_;
      isBurnable_ = other.isBurnable_;
      issueChainId_ = other.issueChainId_;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      nftType_ = other.nftType_;
      protocolName_ = other.protocolName_;
      isTokenIdReuse_ = other.isTokenIdReuse_;
      issued_ = other.issued_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTProtocolInfo Clone() {
      return new NFTProtocolInfo(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// The symbol of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "supply" field.</summary>
    public const int SupplyFieldNumber = 2;
    private long supply_;
    /// <summary>
    /// The minted number of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Supply {
      get { return supply_; }
      set {
        supply_ = value;
      }
    }

    /// <summary>Field number for the "total_supply" field.</summary>
    public const int TotalSupplyFieldNumber = 3;
    private long totalSupply_;
    /// <summary>
    /// The total number of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TotalSupply {
      get { return totalSupply_; }
      set {
        totalSupply_ = value;
      }
    }

    /// <summary>Field number for the "creator" field.</summary>
    public const int CreatorFieldNumber = 4;
    private global::AElf.Types.Address creator_;
    /// <summary>
    /// The address that creat the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Creator {
      get { return creator_; }
      set {
        creator_ = value;
      }
    }

    /// <summary>Field number for the "base_uri" field.</summary>
    public const int BaseUriFieldNumber = 5;
    private string baseUri_ = "";
    /// <summary>
    /// Base Uri.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BaseUri {
      get { return baseUri_; }
      set {
        baseUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_burnable" field.</summary>
    public const int IsBurnableFieldNumber = 6;
    private bool isBurnable_;
    /// <summary>
    /// A flag indicating if this token is burnable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBurnable {
      get { return isBurnable_; }
      set {
        isBurnable_ = value;
      }
    }

    /// <summary>Field number for the "issue_chain_id" field.</summary>
    public const int IssueChainIdFieldNumber = 7;
    private int issueChainId_;
    /// <summary>
    /// The chain to mint this token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int IssueChainId {
      get { return issueChainId_; }
      set {
        issueChainId_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 8;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    /// <summary>
    /// The metadata of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "nft_type" field.</summary>
    public const int NftTypeFieldNumber = 9;
    private string nftType_ = "";
    /// <summary>
    /// NFT Type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NftType {
      get { return nftType_; }
      set {
        nftType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "protocol_name" field.</summary>
    public const int ProtocolNameFieldNumber = 10;
    private string protocolName_ = "";
    /// <summary>
    /// Protocol name, aka token name in MultiToken Contract.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProtocolName {
      get { return protocolName_; }
      set {
        protocolName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_token_id_reuse" field.</summary>
    public const int IsTokenIdReuseFieldNumber = 11;
    private bool isTokenIdReuse_;
    /// <summary>
    /// Is token id can be reused.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTokenIdReuse {
      get { return isTokenIdReuse_; }
      set {
        isTokenIdReuse_ = value;
      }
    }

    /// <summary>Field number for the "issued" field.</summary>
    public const int IssuedFieldNumber = 12;
    private long issued_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Issued {
      get { return issued_; }
      set {
        issued_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NFTProtocolInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NFTProtocolInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (Supply != other.Supply) return false;
      if (TotalSupply != other.TotalSupply) return false;
      if (!object.Equals(Creator, other.Creator)) return false;
      if (BaseUri != other.BaseUri) return false;
      if (IsBurnable != other.IsBurnable) return false;
      if (IssueChainId != other.IssueChainId) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (NftType != other.NftType) return false;
      if (ProtocolName != other.ProtocolName) return false;
      if (IsTokenIdReuse != other.IsTokenIdReuse) return false;
      if (Issued != other.Issued) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (Supply != 0L) hash ^= Supply.GetHashCode();
      if (TotalSupply != 0L) hash ^= TotalSupply.GetHashCode();
      if (creator_ != null) hash ^= Creator.GetHashCode();
      if (BaseUri.Length != 0) hash ^= BaseUri.GetHashCode();
      if (IsBurnable != false) hash ^= IsBurnable.GetHashCode();
      if (IssueChainId != 0) hash ^= IssueChainId.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (NftType.Length != 0) hash ^= NftType.GetHashCode();
      if (ProtocolName.Length != 0) hash ^= ProtocolName.GetHashCode();
      if (IsTokenIdReuse != false) hash ^= IsTokenIdReuse.GetHashCode();
      if (Issued != 0L) hash ^= Issued.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (Supply != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Supply);
      }
      if (TotalSupply != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSupply);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(BaseUri);
      }
      if (IsBurnable != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsBurnable);
      }
      if (IssueChainId != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(IssueChainId);
      }
      if (metadata_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Metadata);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(NftType);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(ProtocolName);
      }
      if (IsTokenIdReuse != false) {
        output.WriteRawTag(88);
        output.WriteBool(IsTokenIdReuse);
      }
      if (Issued != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(Issued);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (Supply != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Supply);
      }
      if (TotalSupply != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSupply);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(BaseUri);
      }
      if (IsBurnable != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsBurnable);
      }
      if (IssueChainId != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(IssueChainId);
      }
      if (metadata_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Metadata);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(NftType);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(ProtocolName);
      }
      if (IsTokenIdReuse != false) {
        output.WriteRawTag(88);
        output.WriteBool(IsTokenIdReuse);
      }
      if (Issued != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(Issued);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (Supply != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Supply);
      }
      if (TotalSupply != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalSupply);
      }
      if (creator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Creator);
      }
      if (BaseUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BaseUri);
      }
      if (IsBurnable != false) {
        size += 1 + 1;
      }
      if (IssueChainId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(IssueChainId);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (NftType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NftType);
      }
      if (ProtocolName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProtocolName);
      }
      if (IsTokenIdReuse != false) {
        size += 1 + 1;
      }
      if (Issued != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Issued);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NFTProtocolInfo other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.Supply != 0L) {
        Supply = other.Supply;
      }
      if (other.TotalSupply != 0L) {
        TotalSupply = other.TotalSupply;
      }
      if (other.creator_ != null) {
        if (creator_ == null) {
          Creator = new global::AElf.Types.Address();
        }
        Creator.MergeFrom(other.Creator);
      }
      if (other.BaseUri.Length != 0) {
        BaseUri = other.BaseUri;
      }
      if (other.IsBurnable != false) {
        IsBurnable = other.IsBurnable;
      }
      if (other.IssueChainId != 0) {
        IssueChainId = other.IssueChainId;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.NftType.Length != 0) {
        NftType = other.NftType;
      }
      if (other.ProtocolName.Length != 0) {
        ProtocolName = other.ProtocolName;
      }
      if (other.IsTokenIdReuse != false) {
        IsTokenIdReuse = other.IsTokenIdReuse;
      }
      if (other.Issued != 0L) {
        Issued = other.Issued;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            Supply = input.ReadInt64();
            break;
          }
          case 24: {
            TotalSupply = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 42: {
            BaseUri = input.ReadString();
            break;
          }
          case 48: {
            IsBurnable = input.ReadBool();
            break;
          }
          case 56: {
            IssueChainId = input.ReadInt32();
            break;
          }
          case 66: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 74: {
            NftType = input.ReadString();
            break;
          }
          case 82: {
            ProtocolName = input.ReadString();
            break;
          }
          case 88: {
            IsTokenIdReuse = input.ReadBool();
            break;
          }
          case 96: {
            Issued = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            Supply = input.ReadInt64();
            break;
          }
          case 24: {
            TotalSupply = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 42: {
            BaseUri = input.ReadString();
            break;
          }
          case 48: {
            IsBurnable = input.ReadBool();
            break;
          }
          case 56: {
            IssueChainId = input.ReadInt32();
            break;
          }
          case 66: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 74: {
            NftType = input.ReadString();
            break;
          }
          case 82: {
            ProtocolName = input.ReadString();
            break;
          }
          case 88: {
            IsTokenIdReuse = input.ReadBool();
            break;
          }
          case 96: {
            Issued = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NFTInfo : pb::IMessage<NFTInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFTInfo> _parser = new pb::MessageParser<NFTInfo>(() => new NFTInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NFTInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTInfo(NFTInfo other) : this() {
      symbol_ = other.symbol_;
      protocolName_ = other.protocolName_;
      tokenId_ = other.tokenId_;
      creator_ = other.creator_ != null ? other.creator_.Clone() : null;
      minters_ = other.minters_.Clone();
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      quantity_ = other.quantity_;
      uri_ = other.uri_;
      baseUri_ = other.baseUri_;
      alias_ = other.alias_;
      isBurned_ = other.isBurned_;
      nftType_ = other.nftType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTInfo Clone() {
      return new NFTInfo(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// The symbol of the protocol this nft belongs to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "protocol_name" field.</summary>
    public const int ProtocolNameFieldNumber = 2;
    private string protocolName_ = "";
    /// <summary>
    /// The name of the protocol this nft belongs to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProtocolName {
      get { return protocolName_; }
      set {
        protocolName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 3;
    private long tokenId_;
    /// <summary>
    /// Actually is the order of this token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "creator" field.</summary>
    public const int CreatorFieldNumber = 4;
    private global::AElf.Types.Address creator_;
    /// <summary>
    /// The address that creat the base token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Creator {
      get { return creator_; }
      set {
        creator_ = value;
      }
    }

    /// <summary>Field number for the "minters" field.</summary>
    public const int MintersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::AElf.Types.Address> _repeated_minters_codec
        = pb::FieldCodec.ForMessage(42, global::AElf.Types.Address.Parser);
    private readonly pbc::RepeatedField<global::AElf.Types.Address> minters_ = new pbc::RepeatedField<global::AElf.Types.Address>();
    /// <summary>
    /// The addresses that mint this token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::AElf.Types.Address> Minters {
      get { return minters_; }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 6;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    /// <summary>
    /// The metadata of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "quantity" field.</summary>
    public const int QuantityFieldNumber = 7;
    private long quantity_;
    /// <summary>
    /// Minted amount.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Quantity {
      get { return quantity_; }
      set {
        quantity_ = value;
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 8;
    private string uri_ = "";
    /// <summary>
    /// Token Uri.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "base_uri" field.</summary>
    public const int BaseUriFieldNumber = 9;
    private string baseUri_ = "";
    /// <summary>
    /// Base Uri.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BaseUri {
      get { return baseUri_; }
      set {
        baseUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 10;
    private string alias_ = "";
    /// <summary>
    /// Alias
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_burned" field.</summary>
    public const int IsBurnedFieldNumber = 11;
    private bool isBurned_;
    /// <summary>
    /// Is burned.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBurned {
      get { return isBurned_; }
      set {
        isBurned_ = value;
      }
    }

    /// <summary>Field number for the "nft_type" field.</summary>
    public const int NftTypeFieldNumber = 12;
    private string nftType_ = "";
    /// <summary>
    /// NFT Type
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NftType {
      get { return nftType_; }
      set {
        nftType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NFTInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NFTInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (ProtocolName != other.ProtocolName) return false;
      if (TokenId != other.TokenId) return false;
      if (!object.Equals(Creator, other.Creator)) return false;
      if(!minters_.Equals(other.minters_)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (Quantity != other.Quantity) return false;
      if (Uri != other.Uri) return false;
      if (BaseUri != other.BaseUri) return false;
      if (Alias != other.Alias) return false;
      if (IsBurned != other.IsBurned) return false;
      if (NftType != other.NftType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (ProtocolName.Length != 0) hash ^= ProtocolName.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (creator_ != null) hash ^= Creator.GetHashCode();
      hash ^= minters_.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (Quantity != 0L) hash ^= Quantity.GetHashCode();
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (BaseUri.Length != 0) hash ^= BaseUri.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      if (IsBurned != false) hash ^= IsBurned.GetHashCode();
      if (NftType.Length != 0) hash ^= NftType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      minters_.WriteTo(output, _repeated_minters_codec);
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (Quantity != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(Quantity);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Uri);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(BaseUri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Alias);
      }
      if (IsBurned != false) {
        output.WriteRawTag(88);
        output.WriteBool(IsBurned);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(NftType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      minters_.WriteTo(ref output, _repeated_minters_codec);
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (Quantity != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(Quantity);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Uri);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(BaseUri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Alias);
      }
      if (IsBurned != false) {
        output.WriteRawTag(88);
        output.WriteBool(IsBurned);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(NftType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (ProtocolName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProtocolName);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (creator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Creator);
      }
      size += minters_.CalculateSize(_repeated_minters_codec);
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (Quantity != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Quantity);
      }
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (BaseUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BaseUri);
      }
      if (Alias.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Alias);
      }
      if (IsBurned != false) {
        size += 1 + 1;
      }
      if (NftType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NftType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NFTInfo other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.ProtocolName.Length != 0) {
        ProtocolName = other.ProtocolName;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.creator_ != null) {
        if (creator_ == null) {
          Creator = new global::AElf.Types.Address();
        }
        Creator.MergeFrom(other.Creator);
      }
      minters_.Add(other.minters_);
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.Quantity != 0L) {
        Quantity = other.Quantity;
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      if (other.BaseUri.Length != 0) {
        BaseUri = other.BaseUri;
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      if (other.IsBurned != false) {
        IsBurned = other.IsBurned;
      }
      if (other.NftType.Length != 0) {
        NftType = other.NftType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 42: {
            minters_.AddEntriesFrom(input, _repeated_minters_codec);
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 56: {
            Quantity = input.ReadInt64();
            break;
          }
          case 66: {
            Uri = input.ReadString();
            break;
          }
          case 74: {
            BaseUri = input.ReadString();
            break;
          }
          case 82: {
            Alias = input.ReadString();
            break;
          }
          case 88: {
            IsBurned = input.ReadBool();
            break;
          }
          case 98: {
            NftType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 42: {
            minters_.AddEntriesFrom(ref input, _repeated_minters_codec);
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 56: {
            Quantity = input.ReadInt64();
            break;
          }
          case 66: {
            Uri = input.ReadString();
            break;
          }
          case 74: {
            BaseUri = input.ReadString();
            break;
          }
          case 82: {
            Alias = input.ReadString();
            break;
          }
          case 88: {
            IsBurned = input.ReadBool();
            break;
          }
          case 98: {
            NftType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Metadata : pb::IMessage<Metadata>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Metadata> _parser = new pb::MessageParser<Metadata>(() => new Metadata());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Metadata> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Metadata() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Metadata(Metadata other) : this() {
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Metadata Clone() {
      return new Metadata(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private static readonly pbc::MapField<string, string>.Codec _map_value_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 10);
    private readonly pbc::MapField<string, string> value_ = new pbc::MapField<string, string>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Metadata);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Metadata other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Value.Equals(other.Value)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      value_.WriteTo(output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      value_.WriteTo(ref output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += value_.CalculateSize(_map_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Metadata other) {
      if (other == null) {
        return;
      }
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            value_.AddEntriesFrom(input, _map_value_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            value_.AddEntriesFrom(ref input, _map_value_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AddMintersInput : pb::IMessage<AddMintersInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AddMintersInput> _parser = new pb::MessageParser<AddMintersInput>(() => new AddMintersInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AddMintersInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddMintersInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddMintersInput(AddMintersInput other) : this() {
      minterList_ = other.minterList_ != null ? other.minterList_.Clone() : null;
      symbol_ = other.symbol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddMintersInput Clone() {
      return new AddMintersInput(this);
    }

    /// <summary>Field number for the "minter_list" field.</summary>
    public const int MinterListFieldNumber = 1;
    private global::AElf.Contracts.NFT.MinterList minterList_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.MinterList MinterList {
      get { return minterList_; }
      set {
        minterList_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AddMintersInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AddMintersInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MinterList, other.MinterList)) return false;
      if (Symbol != other.Symbol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (minterList_ != null) hash ^= MinterList.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (minterList_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinterList);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AddMintersInput other) {
      if (other == null) {
        return;
      }
      if (other.minterList_ != null) {
        if (minterList_ == null) {
          MinterList = new global::AElf.Contracts.NFT.MinterList();
        }
        MinterList.MergeFrom(other.MinterList);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class RemoveMintersInput : pb::IMessage<RemoveMintersInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RemoveMintersInput> _parser = new pb::MessageParser<RemoveMintersInput>(() => new RemoveMintersInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RemoveMintersInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemoveMintersInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemoveMintersInput(RemoveMintersInput other) : this() {
      minterList_ = other.minterList_ != null ? other.minterList_.Clone() : null;
      symbol_ = other.symbol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemoveMintersInput Clone() {
      return new RemoveMintersInput(this);
    }

    /// <summary>Field number for the "minter_list" field.</summary>
    public const int MinterListFieldNumber = 1;
    private global::AElf.Contracts.NFT.MinterList minterList_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.MinterList MinterList {
      get { return minterList_; }
      set {
        minterList_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RemoveMintersInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RemoveMintersInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MinterList, other.MinterList)) return false;
      if (Symbol != other.Symbol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (minterList_ != null) hash ^= MinterList.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (minterList_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinterList);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RemoveMintersInput other) {
      if (other == null) {
        return;
      }
      if (other.minterList_ != null) {
        if (minterList_ == null) {
          MinterList = new global::AElf.Contracts.NFT.MinterList();
        }
        MinterList.MergeFrom(other.MinterList);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class GetNFTInfoInput : pb::IMessage<GetNFTInfoInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GetNFTInfoInput> _parser = new pb::MessageParser<GetNFTInfoInput>(() => new GetNFTInfoInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetNFTInfoInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetNFTInfoInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetNFTInfoInput(GetNFTInfoInput other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetNFTInfoInput Clone() {
      return new GetNFTInfoInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetNFTInfoInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetNFTInfoInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetNFTInfoInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class RecastInput : pb::IMessage<RecastInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RecastInput> _parser = new pb::MessageParser<RecastInput>(() => new RecastInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RecastInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RecastInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RecastInput(RecastInput other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      uri_ = other.uri_;
      alias_ = other.alias_;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RecastInput Clone() {
      return new RecastInput(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 3;
    private string uri_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 4;
    private string alias_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 5;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RecastInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RecastInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Uri != other.Uri) return false;
      if (Alias != other.Alias) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Alias);
      }
      if (metadata_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Metadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Uri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Alias);
      }
      if (metadata_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Metadata);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (Alias.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Alias);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RecastInput other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            Uri = input.ReadString();
            break;
          }
          case 34: {
            Alias = input.ReadString();
            break;
          }
          case 42: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            Uri = input.ReadString();
            break;
          }
          case 34: {
            Alias = input.ReadString();
            break;
          }
          case 42: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AssembledNfts : pb::IMessage<AssembledNfts>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AssembledNfts> _parser = new pb::MessageParser<AssembledNfts>(() => new AssembledNfts());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AssembledNfts> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[29]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembledNfts() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembledNfts(AssembledNfts other) : this() {
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembledNfts Clone() {
      return new AssembledNfts(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private static readonly pbc::MapField<string, long>.Codec _map_value_codec
        = new pbc::MapField<string, long>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForInt64(16, 0L), 10);
    private readonly pbc::MapField<string, long> value_ = new pbc::MapField<string, long>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, long> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AssembledNfts);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AssembledNfts other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Value.Equals(other.Value)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      value_.WriteTo(output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      value_.WriteTo(ref output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += value_.CalculateSize(_map_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AssembledNfts other) {
      if (other == null) {
        return;
      }
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            value_.AddEntriesFrom(input, _map_value_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            value_.AddEntriesFrom(ref input, _map_value_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AssembledFts : pb::IMessage<AssembledFts>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AssembledFts> _parser = new pb::MessageParser<AssembledFts>(() => new AssembledFts());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AssembledFts> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[30]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembledFts() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembledFts(AssembledFts other) : this() {
      value_ = other.value_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AssembledFts Clone() {
      return new AssembledFts(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private static readonly pbc::MapField<string, long>.Codec _map_value_codec
        = new pbc::MapField<string, long>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForInt64(16, 0L), 10);
    private readonly pbc::MapField<string, long> value_ = new pbc::MapField<string, long>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, long> Value {
      get { return value_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AssembledFts);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AssembledFts other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Value.Equals(other.Value)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      value_.WriteTo(output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      value_.WriteTo(ref output, _map_value_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += value_.CalculateSize(_map_value_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AssembledFts other) {
      if (other == null) {
        return;
      }
      value_.Add(other.value_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            value_.AddEntriesFrom(input, _map_value_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            value_.AddEntriesFrom(ref input, _map_value_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AddNFTTypeInput : pb::IMessage<AddNFTTypeInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AddNFTTypeInput> _parser = new pb::MessageParser<AddNFTTypeInput>(() => new AddNFTTypeInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AddNFTTypeInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[31]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddNFTTypeInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddNFTTypeInput(AddNFTTypeInput other) : this() {
      fullName_ = other.fullName_;
      shortName_ = other.shortName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddNFTTypeInput Clone() {
      return new AddNFTTypeInput(this);
    }

    /// <summary>Field number for the "full_name" field.</summary>
    public const int FullNameFieldNumber = 1;
    private string fullName_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FullName {
      get { return fullName_; }
      set {
        fullName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "short_name" field.</summary>
    public const int ShortNameFieldNumber = 2;
    private string shortName_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ShortName {
      get { return shortName_; }
      set {
        shortName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AddNFTTypeInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AddNFTTypeInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FullName != other.FullName) return false;
      if (ShortName != other.ShortName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (FullName.Length != 0) hash ^= FullName.GetHashCode();
      if (ShortName.Length != 0) hash ^= ShortName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (FullName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FullName);
      }
      if (ShortName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ShortName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (FullName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FullName);
      }
      if (ShortName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ShortName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (FullName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FullName);
      }
      if (ShortName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShortName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AddNFTTypeInput other) {
      if (other == null) {
        return;
      }
      if (other.FullName.Length != 0) {
        FullName = other.FullName;
      }
      if (other.ShortName.Length != 0) {
        ShortName = other.ShortName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            FullName = input.ReadString();
            break;
          }
          case 18: {
            ShortName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            FullName = input.ReadString();
            break;
          }
          case 18: {
            ShortName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NFTProtocolCreated : pb::IMessage<NFTProtocolCreated>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFTProtocolCreated> _parser = new pb::MessageParser<NFTProtocolCreated>(() => new NFTProtocolCreated());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NFTProtocolCreated> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[32]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTProtocolCreated() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTProtocolCreated(NFTProtocolCreated other) : this() {
      symbol_ = other.symbol_;
      protocolName_ = other.protocolName_;
      totalSupply_ = other.totalSupply_;
      creator_ = other.creator_ != null ? other.creator_.Clone() : null;
      isBurnable_ = other.isBurnable_;
      issueChainId_ = other.issueChainId_;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      baseUri_ = other.baseUri_;
      isTokenIdReuse_ = other.isTokenIdReuse_;
      nftType_ = other.nftType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTProtocolCreated Clone() {
      return new NFTProtocolCreated(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// The symbol of this protocol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "protocol_name" field.</summary>
    public const int ProtocolNameFieldNumber = 2;
    private string protocolName_ = "";
    /// <summary>
    /// The name of this protocol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProtocolName {
      get { return protocolName_; }
      set {
        protocolName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "total_supply" field.</summary>
    public const int TotalSupplyFieldNumber = 3;
    private long totalSupply_;
    /// <summary>
    /// The total supply of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TotalSupply {
      get { return totalSupply_; }
      set {
        totalSupply_ = value;
      }
    }

    /// <summary>Field number for the "creator" field.</summary>
    public const int CreatorFieldNumber = 4;
    private global::AElf.Types.Address creator_;
    /// <summary>
    /// The address that created the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Creator {
      get { return creator_; }
      set {
        creator_ = value;
      }
    }

    /// <summary>Field number for the "is_burnable" field.</summary>
    public const int IsBurnableFieldNumber = 5;
    private bool isBurnable_;
    /// <summary>
    /// A flag indicating if this token is burnable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBurnable {
      get { return isBurnable_; }
      set {
        isBurnable_ = value;
      }
    }

    /// <summary>Field number for the "issue_chain_id" field.</summary>
    public const int IssueChainIdFieldNumber = 6;
    private int issueChainId_;
    /// <summary>
    /// The chain id of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int IssueChainId {
      get { return issueChainId_; }
      set {
        issueChainId_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 7;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    /// <summary>
    /// The metadata of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "base_uri" field.</summary>
    public const int BaseUriFieldNumber = 8;
    private string baseUri_ = "";
    /// <summary>
    /// Base Uri.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BaseUri {
      get { return baseUri_; }
      set {
        baseUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_token_id_reuse" field.</summary>
    public const int IsTokenIdReuseFieldNumber = 9;
    private bool isTokenIdReuse_;
    /// <summary>
    /// Is token id can be reused.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsTokenIdReuse {
      get { return isTokenIdReuse_; }
      set {
        isTokenIdReuse_ = value;
      }
    }

    /// <summary>Field number for the "nft_type" field.</summary>
    public const int NftTypeFieldNumber = 10;
    private string nftType_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NftType {
      get { return nftType_; }
      set {
        nftType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NFTProtocolCreated);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NFTProtocolCreated other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (ProtocolName != other.ProtocolName) return false;
      if (TotalSupply != other.TotalSupply) return false;
      if (!object.Equals(Creator, other.Creator)) return false;
      if (IsBurnable != other.IsBurnable) return false;
      if (IssueChainId != other.IssueChainId) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (BaseUri != other.BaseUri) return false;
      if (IsTokenIdReuse != other.IsTokenIdReuse) return false;
      if (NftType != other.NftType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (ProtocolName.Length != 0) hash ^= ProtocolName.GetHashCode();
      if (TotalSupply != 0L) hash ^= TotalSupply.GetHashCode();
      if (creator_ != null) hash ^= Creator.GetHashCode();
      if (IsBurnable != false) hash ^= IsBurnable.GetHashCode();
      if (IssueChainId != 0) hash ^= IssueChainId.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (BaseUri.Length != 0) hash ^= BaseUri.GetHashCode();
      if (IsTokenIdReuse != false) hash ^= IsTokenIdReuse.GetHashCode();
      if (NftType.Length != 0) hash ^= NftType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TotalSupply != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSupply);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (IsBurnable != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsBurnable);
      }
      if (IssueChainId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(IssueChainId);
      }
      if (metadata_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(BaseUri);
      }
      if (IsTokenIdReuse != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsTokenIdReuse);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(NftType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TotalSupply != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TotalSupply);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (IsBurnable != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsBurnable);
      }
      if (IssueChainId != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(IssueChainId);
      }
      if (metadata_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Metadata);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(BaseUri);
      }
      if (IsTokenIdReuse != false) {
        output.WriteRawTag(72);
        output.WriteBool(IsTokenIdReuse);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(NftType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (ProtocolName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProtocolName);
      }
      if (TotalSupply != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalSupply);
      }
      if (creator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Creator);
      }
      if (IsBurnable != false) {
        size += 1 + 1;
      }
      if (IssueChainId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(IssueChainId);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (BaseUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BaseUri);
      }
      if (IsTokenIdReuse != false) {
        size += 1 + 1;
      }
      if (NftType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NftType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NFTProtocolCreated other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.ProtocolName.Length != 0) {
        ProtocolName = other.ProtocolName;
      }
      if (other.TotalSupply != 0L) {
        TotalSupply = other.TotalSupply;
      }
      if (other.creator_ != null) {
        if (creator_ == null) {
          Creator = new global::AElf.Types.Address();
        }
        Creator.MergeFrom(other.Creator);
      }
      if (other.IsBurnable != false) {
        IsBurnable = other.IsBurnable;
      }
      if (other.IssueChainId != 0) {
        IssueChainId = other.IssueChainId;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.BaseUri.Length != 0) {
        BaseUri = other.BaseUri;
      }
      if (other.IsTokenIdReuse != false) {
        IsTokenIdReuse = other.IsTokenIdReuse;
      }
      if (other.NftType.Length != 0) {
        NftType = other.NftType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TotalSupply = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 40: {
            IsBurnable = input.ReadBool();
            break;
          }
          case 48: {
            IssueChainId = input.ReadInt32();
            break;
          }
          case 58: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 66: {
            BaseUri = input.ReadString();
            break;
          }
          case 72: {
            IsTokenIdReuse = input.ReadBool();
            break;
          }
          case 82: {
            NftType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TotalSupply = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 40: {
            IsBurnable = input.ReadBool();
            break;
          }
          case 48: {
            IssueChainId = input.ReadInt32();
            break;
          }
          case 58: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 66: {
            BaseUri = input.ReadString();
            break;
          }
          case 72: {
            IsTokenIdReuse = input.ReadBool();
            break;
          }
          case 82: {
            NftType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NFTMinted : pb::IMessage<NFTMinted>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFTMinted> _parser = new pb::MessageParser<NFTMinted>(() => new NFTMinted());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NFTMinted> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[33]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTMinted() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTMinted(NFTMinted other) : this() {
      symbol_ = other.symbol_;
      protocolName_ = other.protocolName_;
      tokenId_ = other.tokenId_;
      creator_ = other.creator_ != null ? other.creator_.Clone() : null;
      minter_ = other.minter_ != null ? other.minter_.Clone() : null;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      uri_ = other.uri_;
      baseUri_ = other.baseUri_;
      alias_ = other.alias_;
      nftType_ = other.nftType_;
      quantity_ = other.quantity_;
      totalQuantity_ = other.totalQuantity_;
      tokenHash_ = other.tokenHash_ != null ? other.tokenHash_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTMinted Clone() {
      return new NFTMinted(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    /// <summary>
    /// The symbol of this protocol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "protocol_name" field.</summary>
    public const int ProtocolNameFieldNumber = 2;
    private string protocolName_ = "";
    /// <summary>
    /// The name of this protocol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProtocolName {
      get { return protocolName_; }
      set {
        protocolName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 3;
    private long tokenId_;
    /// <summary>
    /// Actually is the order of this token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "creator" field.</summary>
    public const int CreatorFieldNumber = 4;
    private global::AElf.Types.Address creator_;
    /// <summary>
    /// The address that creat the base token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Creator {
      get { return creator_; }
      set {
        creator_ = value;
      }
    }

    /// <summary>Field number for the "minter" field.</summary>
    public const int MinterFieldNumber = 5;
    private global::AElf.Types.Address minter_;
    /// <summary>
    /// The address that mint this token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Minter {
      get { return minter_; }
      set {
        minter_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 6;
    private global::AElf.Contracts.NFT.Metadata metadata_;
    /// <summary>
    /// The metadata of the token.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 7;
    private global::AElf.Types.Address owner_;
    /// <summary>
    /// The current owner of this nft.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 8;
    private string uri_ = "";
    /// <summary>
    /// Token Uri.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "base_uri" field.</summary>
    public const int BaseUriFieldNumber = 9;
    private string baseUri_ = "";
    /// <summary>
    /// Base Uri.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BaseUri {
      get { return baseUri_; }
      set {
        baseUri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 10;
    private string alias_ = "";
    /// <summary>
    /// Alias
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "nft_type" field.</summary>
    public const int NftTypeFieldNumber = 11;
    private string nftType_ = "";
    /// <summary>
    /// NFT Type
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NftType {
      get { return nftType_; }
      set {
        nftType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "quantity" field.</summary>
    public const int QuantityFieldNumber = 12;
    private long quantity_;
    /// <summary>
    /// Quantity
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Quantity {
      get { return quantity_; }
      set {
        quantity_ = value;
      }
    }

    /// <summary>Field number for the "total_quantity" field.</summary>
    public const int TotalQuantityFieldNumber = 13;
    private long totalQuantity_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TotalQuantity {
      get { return totalQuantity_; }
      set {
        totalQuantity_ = value;
      }
    }

    /// <summary>Field number for the "token_hash" field.</summary>
    public const int TokenHashFieldNumber = 14;
    private global::AElf.Types.Hash tokenHash_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Hash TokenHash {
      get { return tokenHash_; }
      set {
        tokenHash_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NFTMinted);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NFTMinted other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (ProtocolName != other.ProtocolName) return false;
      if (TokenId != other.TokenId) return false;
      if (!object.Equals(Creator, other.Creator)) return false;
      if (!object.Equals(Minter, other.Minter)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Owner, other.Owner)) return false;
      if (Uri != other.Uri) return false;
      if (BaseUri != other.BaseUri) return false;
      if (Alias != other.Alias) return false;
      if (NftType != other.NftType) return false;
      if (Quantity != other.Quantity) return false;
      if (TotalQuantity != other.TotalQuantity) return false;
      if (!object.Equals(TokenHash, other.TokenHash)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (ProtocolName.Length != 0) hash ^= ProtocolName.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (creator_ != null) hash ^= Creator.GetHashCode();
      if (minter_ != null) hash ^= Minter.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (BaseUri.Length != 0) hash ^= BaseUri.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      if (NftType.Length != 0) hash ^= NftType.GetHashCode();
      if (Quantity != 0L) hash ^= Quantity.GetHashCode();
      if (TotalQuantity != 0L) hash ^= TotalQuantity.GetHashCode();
      if (tokenHash_ != null) hash ^= TokenHash.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (minter_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Minter);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (owner_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Owner);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Uri);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(BaseUri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Alias);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(NftType);
      }
      if (Quantity != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(Quantity);
      }
      if (TotalQuantity != 0L) {
        output.WriteRawTag(104);
        output.WriteInt64(TotalQuantity);
      }
      if (tokenHash_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(TokenHash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (ProtocolName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProtocolName);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (creator_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Creator);
      }
      if (minter_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Minter);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (owner_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Owner);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Uri);
      }
      if (BaseUri.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(BaseUri);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Alias);
      }
      if (NftType.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(NftType);
      }
      if (Quantity != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(Quantity);
      }
      if (TotalQuantity != 0L) {
        output.WriteRawTag(104);
        output.WriteInt64(TotalQuantity);
      }
      if (tokenHash_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(TokenHash);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (ProtocolName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProtocolName);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (creator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Creator);
      }
      if (minter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Minter);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (BaseUri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BaseUri);
      }
      if (Alias.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Alias);
      }
      if (NftType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NftType);
      }
      if (Quantity != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Quantity);
      }
      if (TotalQuantity != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TotalQuantity);
      }
      if (tokenHash_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TokenHash);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NFTMinted other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.ProtocolName.Length != 0) {
        ProtocolName = other.ProtocolName;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.creator_ != null) {
        if (creator_ == null) {
          Creator = new global::AElf.Types.Address();
        }
        Creator.MergeFrom(other.Creator);
      }
      if (other.minter_ != null) {
        if (minter_ == null) {
          Minter = new global::AElf.Types.Address();
        }
        Minter.MergeFrom(other.Minter);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::AElf.Contracts.NFT.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      if (other.BaseUri.Length != 0) {
        BaseUri = other.BaseUri;
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      if (other.NftType.Length != 0) {
        NftType = other.NftType;
      }
      if (other.Quantity != 0L) {
        Quantity = other.Quantity;
      }
      if (other.TotalQuantity != 0L) {
        TotalQuantity = other.TotalQuantity;
      }
      if (other.tokenHash_ != null) {
        if (tokenHash_ == null) {
          TokenHash = new global::AElf.Types.Hash();
        }
        TokenHash.MergeFrom(other.TokenHash);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 42: {
            if (minter_ == null) {
              Minter = new global::AElf.Types.Address();
            }
            input.ReadMessage(Minter);
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 58: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 66: {
            Uri = input.ReadString();
            break;
          }
          case 74: {
            BaseUri = input.ReadString();
            break;
          }
          case 82: {
            Alias = input.ReadString();
            break;
          }
          case 90: {
            NftType = input.ReadString();
            break;
          }
          case 96: {
            Quantity = input.ReadInt64();
            break;
          }
          case 104: {
            TotalQuantity = input.ReadInt64();
            break;
          }
          case 114: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 18: {
            ProtocolName = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 34: {
            if (creator_ == null) {
              Creator = new global::AElf.Types.Address();
            }
            input.ReadMessage(Creator);
            break;
          }
          case 42: {
            if (minter_ == null) {
              Minter = new global::AElf.Types.Address();
            }
            input.ReadMessage(Minter);
            break;
          }
          case 50: {
            if (metadata_ == null) {
              Metadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 58: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 66: {
            Uri = input.ReadString();
            break;
          }
          case 74: {
            BaseUri = input.ReadString();
            break;
          }
          case 82: {
            Alias = input.ReadString();
            break;
          }
          case 90: {
            NftType = input.ReadString();
            break;
          }
          case 96: {
            Quantity = input.ReadInt64();
            break;
          }
          case 104: {
            TotalQuantity = input.ReadInt64();
            break;
          }
          case 114: {
            if (tokenHash_ == null) {
              TokenHash = new global::AElf.Types.Hash();
            }
            input.ReadMessage(TokenHash);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Transferred : pb::IMessage<Transferred>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Transferred> _parser = new pb::MessageParser<Transferred>(() => new Transferred());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Transferred> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[34]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Transferred() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Transferred(Transferred other) : this() {
      from_ = other.from_ != null ? other.from_.Clone() : null;
      to_ = other.to_ != null ? other.to_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      amount_ = other.amount_;
      memo_ = other.memo_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Transferred Clone() {
      return new Transferred(this);
    }

    /// <summary>Field number for the "from" field.</summary>
    public const int FromFieldNumber = 1;
    private global::AElf.Types.Address from_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address From {
      get { return from_; }
      set {
        from_ = value;
      }
    }

    /// <summary>Field number for the "to" field.</summary>
    public const int ToFieldNumber = 2;
    private global::AElf.Types.Address to_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address To {
      get { return to_; }
      set {
        to_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 3;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 4;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 5;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    /// <summary>Field number for the "memo" field.</summary>
    public const int MemoFieldNumber = 6;
    private string memo_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Memo {
      get { return memo_; }
      set {
        memo_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Transferred);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Transferred other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(From, other.From)) return false;
      if (!object.Equals(To, other.To)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Amount != other.Amount) return false;
      if (Memo != other.Memo) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (from_ != null) hash ^= From.GetHashCode();
      if (to_ != null) hash ^= To.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (Memo.Length != 0) hash ^= Memo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (from_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(From);
      }
      if (to_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(To);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Amount);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Memo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (from_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(From);
      }
      if (to_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(To);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Amount);
      }
      if (Memo.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Memo);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (from_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(From);
      }
      if (to_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(To);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (Memo.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Memo);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Transferred other) {
      if (other == null) {
        return;
      }
      if (other.from_ != null) {
        if (from_ == null) {
          From = new global::AElf.Types.Address();
        }
        From.MergeFrom(other.From);
      }
      if (other.to_ != null) {
        if (to_ == null) {
          To = new global::AElf.Types.Address();
        }
        To.MergeFrom(other.To);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      if (other.Memo.Length != 0) {
        Memo = other.Memo;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (from_ == null) {
              From = new global::AElf.Types.Address();
            }
            input.ReadMessage(From);
            break;
          }
          case 18: {
            if (to_ == null) {
              To = new global::AElf.Types.Address();
            }
            input.ReadMessage(To);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 40: {
            Amount = input.ReadInt64();
            break;
          }
          case 50: {
            Memo = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (from_ == null) {
              From = new global::AElf.Types.Address();
            }
            input.ReadMessage(From);
            break;
          }
          case 18: {
            if (to_ == null) {
              To = new global::AElf.Types.Address();
            }
            input.ReadMessage(To);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 40: {
            Amount = input.ReadInt64();
            break;
          }
          case 50: {
            Memo = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Approved : pb::IMessage<Approved>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Approved> _parser = new pb::MessageParser<Approved>(() => new Approved());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Approved> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[35]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Approved() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Approved(Approved other) : this() {
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Approved Clone() {
      return new Approved(this);
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 1;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 2;
    private global::AElf.Types.Address spender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 3;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 4;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 5;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Approved);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Approved other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Approved other) {
      if (other == null) {
        return;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::AElf.Types.Address();
        }
        Spender.MergeFrom(other.Spender);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 40: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 40: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class UnApproved : pb::IMessage<UnApproved>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<UnApproved> _parser = new pb::MessageParser<UnApproved>(() => new UnApproved());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UnApproved> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[36]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UnApproved() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UnApproved(UnApproved other) : this() {
      owner_ = other.owner_ != null ? other.owner_.Clone() : null;
      spender_ = other.spender_ != null ? other.spender_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      currentAllowance_ = other.currentAllowance_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UnApproved Clone() {
      return new UnApproved(this);
    }

    /// <summary>Field number for the "owner" field.</summary>
    public const int OwnerFieldNumber = 1;
    private global::AElf.Types.Address owner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Owner {
      get { return owner_; }
      set {
        owner_ = value;
      }
    }

    /// <summary>Field number for the "spender" field.</summary>
    public const int SpenderFieldNumber = 2;
    private global::AElf.Types.Address spender_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Spender {
      get { return spender_; }
      set {
        spender_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 3;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 4;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "current_allowance" field.</summary>
    public const int CurrentAllowanceFieldNumber = 5;
    private long currentAllowance_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long CurrentAllowance {
      get { return currentAllowance_; }
      set {
        currentAllowance_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UnApproved);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UnApproved other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Owner, other.Owner)) return false;
      if (!object.Equals(Spender, other.Spender)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (CurrentAllowance != other.CurrentAllowance) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (owner_ != null) hash ^= Owner.GetHashCode();
      if (spender_ != null) hash ^= Spender.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (CurrentAllowance != 0L) hash ^= CurrentAllowance.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (CurrentAllowance != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(CurrentAllowance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (owner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Owner);
      }
      if (spender_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spender);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(TokenId);
      }
      if (CurrentAllowance != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(CurrentAllowance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (owner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Owner);
      }
      if (spender_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spender);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (CurrentAllowance != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(CurrentAllowance);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UnApproved other) {
      if (other == null) {
        return;
      }
      if (other.owner_ != null) {
        if (owner_ == null) {
          Owner = new global::AElf.Types.Address();
        }
        Owner.MergeFrom(other.Owner);
      }
      if (other.spender_ != null) {
        if (spender_ == null) {
          Spender = new global::AElf.Types.Address();
        }
        Spender.MergeFrom(other.Spender);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.CurrentAllowance != 0L) {
        CurrentAllowance = other.CurrentAllowance;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 40: {
            CurrentAllowance = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (owner_ == null) {
              Owner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Owner);
            break;
          }
          case 18: {
            if (spender_ == null) {
              Spender = new global::AElf.Types.Address();
            }
            input.ReadMessage(Spender);
            break;
          }
          case 26: {
            Symbol = input.ReadString();
            break;
          }
          case 32: {
            TokenId = input.ReadInt64();
            break;
          }
          case 40: {
            CurrentAllowance = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Burned : pb::IMessage<Burned>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Burned> _parser = new pb::MessageParser<Burned>(() => new Burned());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Burned> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[37]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Burned() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Burned(Burned other) : this() {
      burner_ = other.burner_ != null ? other.burner_.Clone() : null;
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      amount_ = other.amount_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Burned Clone() {
      return new Burned(this);
    }

    /// <summary>Field number for the "burner" field.</summary>
    public const int BurnerFieldNumber = 1;
    private global::AElf.Types.Address burner_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Types.Address Burner {
      get { return burner_; }
      set {
        burner_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 3;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "amount" field.</summary>
    public const int AmountFieldNumber = 4;
    private long amount_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Amount {
      get { return amount_; }
      set {
        amount_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Burned);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Burned other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Burner, other.Burner)) return false;
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (Amount != other.Amount) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (burner_ != null) hash ^= Burner.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (Amount != 0L) hash ^= Amount.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (burner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Burner);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (burner_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Burner);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(TokenId);
      }
      if (Amount != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Amount);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (burner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Burner);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (Amount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Amount);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Burned other) {
      if (other == null) {
        return;
      }
      if (other.burner_ != null) {
        if (burner_ == null) {
          Burner = new global::AElf.Types.Address();
        }
        Burner.MergeFrom(other.Burner);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.Amount != 0L) {
        Amount = other.Amount;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (burner_ == null) {
              Burner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Burner);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (burner_ == null) {
              Burner = new global::AElf.Types.Address();
            }
            input.ReadMessage(Burner);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
          case 24: {
            TokenId = input.ReadInt64();
            break;
          }
          case 32: {
            Amount = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Recasted : pb::IMessage<Recasted>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Recasted> _parser = new pb::MessageParser<Recasted>(() => new Recasted());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Recasted> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[38]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Recasted() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Recasted(Recasted other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      oldMetadata_ = other.oldMetadata_ != null ? other.oldMetadata_.Clone() : null;
      newMetadata_ = other.newMetadata_ != null ? other.newMetadata_.Clone() : null;
      alias_ = other.alias_;
      uri_ = other.uri_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Recasted Clone() {
      return new Recasted(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "old_metadata" field.</summary>
    public const int OldMetadataFieldNumber = 3;
    private global::AElf.Contracts.NFT.Metadata oldMetadata_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata OldMetadata {
      get { return oldMetadata_; }
      set {
        oldMetadata_ = value;
      }
    }

    /// <summary>Field number for the "new_metadata" field.</summary>
    public const int NewMetadataFieldNumber = 4;
    private global::AElf.Contracts.NFT.Metadata newMetadata_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.Metadata NewMetadata {
      get { return newMetadata_; }
      set {
        newMetadata_ = value;
      }
    }

    /// <summary>Field number for the "alias" field.</summary>
    public const int AliasFieldNumber = 5;
    private string alias_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Alias {
      get { return alias_; }
      set {
        alias_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "uri" field.</summary>
    public const int UriFieldNumber = 6;
    private string uri_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Uri {
      get { return uri_; }
      set {
        uri_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Recasted);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Recasted other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (!object.Equals(OldMetadata, other.OldMetadata)) return false;
      if (!object.Equals(NewMetadata, other.NewMetadata)) return false;
      if (Alias != other.Alias) return false;
      if (Uri != other.Uri) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (oldMetadata_ != null) hash ^= OldMetadata.GetHashCode();
      if (newMetadata_ != null) hash ^= NewMetadata.GetHashCode();
      if (Alias.Length != 0) hash ^= Alias.GetHashCode();
      if (Uri.Length != 0) hash ^= Uri.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (oldMetadata_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(OldMetadata);
      }
      if (newMetadata_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NewMetadata);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Alias);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Uri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (oldMetadata_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(OldMetadata);
      }
      if (newMetadata_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NewMetadata);
      }
      if (Alias.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Alias);
      }
      if (Uri.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(Uri);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (oldMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OldMetadata);
      }
      if (newMetadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NewMetadata);
      }
      if (Alias.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Alias);
      }
      if (Uri.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uri);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Recasted other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.oldMetadata_ != null) {
        if (oldMetadata_ == null) {
          OldMetadata = new global::AElf.Contracts.NFT.Metadata();
        }
        OldMetadata.MergeFrom(other.OldMetadata);
      }
      if (other.newMetadata_ != null) {
        if (newMetadata_ == null) {
          NewMetadata = new global::AElf.Contracts.NFT.Metadata();
        }
        NewMetadata.MergeFrom(other.NewMetadata);
      }
      if (other.Alias.Length != 0) {
        Alias = other.Alias;
      }
      if (other.Uri.Length != 0) {
        Uri = other.Uri;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (oldMetadata_ == null) {
              OldMetadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(OldMetadata);
            break;
          }
          case 34: {
            if (newMetadata_ == null) {
              NewMetadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(NewMetadata);
            break;
          }
          case 42: {
            Alias = input.ReadString();
            break;
          }
          case 50: {
            Uri = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (oldMetadata_ == null) {
              OldMetadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(OldMetadata);
            break;
          }
          case 34: {
            if (newMetadata_ == null) {
              NewMetadata = new global::AElf.Contracts.NFT.Metadata();
            }
            input.ReadMessage(NewMetadata);
            break;
          }
          case 42: {
            Alias = input.ReadString();
            break;
          }
          case 50: {
            Uri = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Assembled : pb::IMessage<Assembled>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Assembled> _parser = new pb::MessageParser<Assembled>(() => new Assembled());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Assembled> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[39]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Assembled() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Assembled(Assembled other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      assembledNfts_ = other.assembledNfts_ != null ? other.assembledNfts_.Clone() : null;
      assembledFts_ = other.assembledFts_ != null ? other.assembledFts_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Assembled Clone() {
      return new Assembled(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "assembled_nfts" field.</summary>
    public const int AssembledNftsFieldNumber = 3;
    private global::AElf.Contracts.NFT.AssembledNfts assembledNfts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.AssembledNfts AssembledNfts {
      get { return assembledNfts_; }
      set {
        assembledNfts_ = value;
      }
    }

    /// <summary>Field number for the "assembled_fts" field.</summary>
    public const int AssembledFtsFieldNumber = 4;
    private global::AElf.Contracts.NFT.AssembledFts assembledFts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.AssembledFts AssembledFts {
      get { return assembledFts_; }
      set {
        assembledFts_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Assembled);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Assembled other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (!object.Equals(AssembledNfts, other.AssembledNfts)) return false;
      if (!object.Equals(AssembledFts, other.AssembledFts)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (assembledNfts_ != null) hash ^= AssembledNfts.GetHashCode();
      if (assembledFts_ != null) hash ^= AssembledFts.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (assembledNfts_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AssembledNfts);
      }
      if (assembledFts_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(AssembledFts);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (assembledNfts_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AssembledNfts);
      }
      if (assembledFts_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(AssembledFts);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (assembledNfts_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AssembledNfts);
      }
      if (assembledFts_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AssembledFts);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Assembled other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.assembledNfts_ != null) {
        if (assembledNfts_ == null) {
          AssembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
        }
        AssembledNfts.MergeFrom(other.AssembledNfts);
      }
      if (other.assembledFts_ != null) {
        if (assembledFts_ == null) {
          AssembledFts = new global::AElf.Contracts.NFT.AssembledFts();
        }
        AssembledFts.MergeFrom(other.AssembledFts);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (assembledNfts_ == null) {
              AssembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
            }
            input.ReadMessage(AssembledNfts);
            break;
          }
          case 34: {
            if (assembledFts_ == null) {
              AssembledFts = new global::AElf.Contracts.NFT.AssembledFts();
            }
            input.ReadMessage(AssembledFts);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (assembledNfts_ == null) {
              AssembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
            }
            input.ReadMessage(AssembledNfts);
            break;
          }
          case 34: {
            if (assembledFts_ == null) {
              AssembledFts = new global::AElf.Contracts.NFT.AssembledFts();
            }
            input.ReadMessage(AssembledFts);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class Disassembled : pb::IMessage<Disassembled>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Disassembled> _parser = new pb::MessageParser<Disassembled>(() => new Disassembled());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Disassembled> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[40]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Disassembled() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Disassembled(Disassembled other) : this() {
      symbol_ = other.symbol_;
      tokenId_ = other.tokenId_;
      disassembledNfts_ = other.disassembledNfts_ != null ? other.disassembledNfts_.Clone() : null;
      disassembledFts_ = other.disassembledFts_ != null ? other.disassembledFts_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Disassembled Clone() {
      return new Disassembled(this);
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 1;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_id" field.</summary>
    public const int TokenIdFieldNumber = 2;
    private long tokenId_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TokenId {
      get { return tokenId_; }
      set {
        tokenId_ = value;
      }
    }

    /// <summary>Field number for the "disassembled_nfts" field.</summary>
    public const int DisassembledNftsFieldNumber = 3;
    private global::AElf.Contracts.NFT.AssembledNfts disassembledNfts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.AssembledNfts DisassembledNfts {
      get { return disassembledNfts_; }
      set {
        disassembledNfts_ = value;
      }
    }

    /// <summary>Field number for the "disassembled_fts" field.</summary>
    public const int DisassembledFtsFieldNumber = 4;
    private global::AElf.Contracts.NFT.AssembledFts disassembledFts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.AssembledFts DisassembledFts {
      get { return disassembledFts_; }
      set {
        disassembledFts_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Disassembled);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Disassembled other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Symbol != other.Symbol) return false;
      if (TokenId != other.TokenId) return false;
      if (!object.Equals(DisassembledNfts, other.DisassembledNfts)) return false;
      if (!object.Equals(DisassembledFts, other.DisassembledFts)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (TokenId != 0L) hash ^= TokenId.GetHashCode();
      if (disassembledNfts_ != null) hash ^= DisassembledNfts.GetHashCode();
      if (disassembledFts_ != null) hash ^= DisassembledFts.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (disassembledNfts_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DisassembledNfts);
      }
      if (disassembledFts_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(DisassembledFts);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Symbol.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Symbol);
      }
      if (TokenId != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(TokenId);
      }
      if (disassembledNfts_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(DisassembledNfts);
      }
      if (disassembledFts_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(DisassembledFts);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (TokenId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TokenId);
      }
      if (disassembledNfts_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DisassembledNfts);
      }
      if (disassembledFts_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DisassembledFts);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Disassembled other) {
      if (other == null) {
        return;
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      if (other.TokenId != 0L) {
        TokenId = other.TokenId;
      }
      if (other.disassembledNfts_ != null) {
        if (disassembledNfts_ == null) {
          DisassembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
        }
        DisassembledNfts.MergeFrom(other.DisassembledNfts);
      }
      if (other.disassembledFts_ != null) {
        if (disassembledFts_ == null) {
          DisassembledFts = new global::AElf.Contracts.NFT.AssembledFts();
        }
        DisassembledFts.MergeFrom(other.DisassembledFts);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (disassembledNfts_ == null) {
              DisassembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
            }
            input.ReadMessage(DisassembledNfts);
            break;
          }
          case 34: {
            if (disassembledFts_ == null) {
              DisassembledFts = new global::AElf.Contracts.NFT.AssembledFts();
            }
            input.ReadMessage(DisassembledFts);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Symbol = input.ReadString();
            break;
          }
          case 16: {
            TokenId = input.ReadInt64();
            break;
          }
          case 26: {
            if (disassembledNfts_ == null) {
              DisassembledNfts = new global::AElf.Contracts.NFT.AssembledNfts();
            }
            input.ReadMessage(DisassembledNfts);
            break;
          }
          case 34: {
            if (disassembledFts_ == null) {
              DisassembledFts = new global::AElf.Contracts.NFT.AssembledFts();
            }
            input.ReadMessage(DisassembledFts);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NFTTypeAdded : pb::IMessage<NFTTypeAdded>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFTTypeAdded> _parser = new pb::MessageParser<NFTTypeAdded>(() => new NFTTypeAdded());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NFTTypeAdded> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[41]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypeAdded() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypeAdded(NFTTypeAdded other) : this() {
      fullName_ = other.fullName_;
      shortName_ = other.shortName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypeAdded Clone() {
      return new NFTTypeAdded(this);
    }

    /// <summary>Field number for the "full_name" field.</summary>
    public const int FullNameFieldNumber = 1;
    private string fullName_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FullName {
      get { return fullName_; }
      set {
        fullName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "short_name" field.</summary>
    public const int ShortNameFieldNumber = 2;
    private string shortName_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ShortName {
      get { return shortName_; }
      set {
        shortName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NFTTypeAdded);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NFTTypeAdded other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FullName != other.FullName) return false;
      if (ShortName != other.ShortName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (FullName.Length != 0) hash ^= FullName.GetHashCode();
      if (ShortName.Length != 0) hash ^= ShortName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (FullName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FullName);
      }
      if (ShortName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ShortName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (FullName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FullName);
      }
      if (ShortName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ShortName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (FullName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FullName);
      }
      if (ShortName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShortName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NFTTypeAdded other) {
      if (other == null) {
        return;
      }
      if (other.FullName.Length != 0) {
        FullName = other.FullName;
      }
      if (other.ShortName.Length != 0) {
        ShortName = other.ShortName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            FullName = input.ReadString();
            break;
          }
          case 18: {
            ShortName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            FullName = input.ReadString();
            break;
          }
          case 18: {
            ShortName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class NFTTypeRemoved : pb::IMessage<NFTTypeRemoved>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFTTypeRemoved> _parser = new pb::MessageParser<NFTTypeRemoved>(() => new NFTTypeRemoved());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NFTTypeRemoved> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[42]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypeRemoved() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypeRemoved(NFTTypeRemoved other) : this() {
      shortName_ = other.shortName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NFTTypeRemoved Clone() {
      return new NFTTypeRemoved(this);
    }

    /// <summary>Field number for the "short_name" field.</summary>
    public const int ShortNameFieldNumber = 1;
    private string shortName_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ShortName {
      get { return shortName_; }
      set {
        shortName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NFTTypeRemoved);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NFTTypeRemoved other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ShortName != other.ShortName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ShortName.Length != 0) hash ^= ShortName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ShortName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ShortName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ShortName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(ShortName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ShortName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShortName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NFTTypeRemoved other) {
      if (other == null) {
        return;
      }
      if (other.ShortName.Length != 0) {
        ShortName = other.ShortName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ShortName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ShortName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class MinterListAdded : pb::IMessage<MinterListAdded>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MinterListAdded> _parser = new pb::MessageParser<MinterListAdded>(() => new MinterListAdded());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MinterListAdded> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[43]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterListAdded() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterListAdded(MinterListAdded other) : this() {
      minterList_ = other.minterList_ != null ? other.minterList_.Clone() : null;
      symbol_ = other.symbol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterListAdded Clone() {
      return new MinterListAdded(this);
    }

    /// <summary>Field number for the "minter_list" field.</summary>
    public const int MinterListFieldNumber = 1;
    private global::AElf.Contracts.NFT.MinterList minterList_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.MinterList MinterList {
      get { return minterList_; }
      set {
        minterList_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MinterListAdded);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MinterListAdded other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MinterList, other.MinterList)) return false;
      if (Symbol != other.Symbol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (minterList_ != null) hash ^= MinterList.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (minterList_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinterList);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MinterListAdded other) {
      if (other == null) {
        return;
      }
      if (other.minterList_ != null) {
        if (minterList_ == null) {
          MinterList = new global::AElf.Contracts.NFT.MinterList();
        }
        MinterList.MergeFrom(other.MinterList);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class MinterListRemoved : pb::IMessage<MinterListRemoved>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MinterListRemoved> _parser = new pb::MessageParser<MinterListRemoved>(() => new MinterListRemoved());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MinterListRemoved> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::AElf.Contracts.NFT.NftContractReflection.Descriptor.MessageTypes[44]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterListRemoved() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterListRemoved(MinterListRemoved other) : this() {
      minterList_ = other.minterList_ != null ? other.minterList_.Clone() : null;
      symbol_ = other.symbol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MinterListRemoved Clone() {
      return new MinterListRemoved(this);
    }

    /// <summary>Field number for the "minter_list" field.</summary>
    public const int MinterListFieldNumber = 1;
    private global::AElf.Contracts.NFT.MinterList minterList_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::AElf.Contracts.NFT.MinterList MinterList {
      get { return minterList_; }
      set {
        minterList_ = value;
      }
    }

    /// <summary>Field number for the "symbol" field.</summary>
    public const int SymbolFieldNumber = 2;
    private string symbol_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Symbol {
      get { return symbol_; }
      set {
        symbol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MinterListRemoved);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MinterListRemoved other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(MinterList, other.MinterList)) return false;
      if (Symbol != other.Symbol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (minterList_ != null) hash ^= MinterList.GetHashCode();
      if (Symbol.Length != 0) hash ^= Symbol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (minterList_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(MinterList);
      }
      if (Symbol.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Symbol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (minterList_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MinterList);
      }
      if (Symbol.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MinterListRemoved other) {
      if (other == null) {
        return;
      }
      if (other.minterList_ != null) {
        if (minterList_ == null) {
          MinterList = new global::AElf.Contracts.NFT.MinterList();
        }
        MinterList.MergeFrom(other.MinterList);
      }
      if (other.Symbol.Length != 0) {
        Symbol = other.Symbol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (minterList_ == null) {
              MinterList = new global::AElf.Contracts.NFT.MinterList();
            }
            input.ReadMessage(MinterList);
            break;
          }
          case 18: {
            Symbol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
